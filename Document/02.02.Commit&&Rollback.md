# 数据库提交浅析

在Btree模块,数据库提交的接口为sqlite3BtreeCommit.

```c
/*
** Do both phases of a commit.
*/
int sqlite3BtreeCommit(Btree *p)
{
    int rc;
    sqlite3BtreeEnter(p);
    /* 首先进行第一步 */
    rc = sqlite3BtreeCommitPhaseOne(p, 0);
    if (rc == SQLITE_OK)
    {
        /* 第一步成功之后,才能进行第二步 */
        rc = sqlite3BtreeCommitPhaseTwo(p, 0);
    }
    sqlite3BtreeLeave(p);
    return rc;
}
```

一共分为两个阶段.

## 第一阶段

数据库提交的第一步,主要是创建回滚日志(如果不存在的话),并且写上足够的信息,使得即使出现了突然断电等事件,数据库也能回滚到之前的状态.而且将数据库的脏页数据也刷入磁盘.

```c
/*
** 此函数做两步提交中的第一步,此函数创建回滚日志(如果不存在的话),并且写上足够的信息,使得即使出现了突然断电等事件
** 数据库也能回滚到之前的状态.日志文件的内容会被刷新到磁盘上,只有写完了日志文件,才能对数据库进行修改.
** 此函数返回之后,回滚日志依然保存在磁盘上,我们依然持有着所有的锁,还需要调用sqlite3BtreeCommitPhaseTwo()进行
** 第二步提交.
**
** This call is a no-op if no write-transaction is currently active on pBt.
**
** Otherwise, sync the database file for the btree pBt. zMaster points to
** the name of a master journal file that should be written into the
** individual journal file, or is NULL, indicating no master journal file
** (single database transaction).
**
** When this is called, the master journal should already have been
** created, populated with this journal pointer and synced to disk.
**
** Once this is routine has returned, the only thing required to commit
** the write-transaction for this database file is to delete the journal.
*/
int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster)
{
    int rc = SQLITE_OK;
    if (p->inTrans == TRANS_WRITE)
    {
        BtShared *pBt = p->pBt;
        sqlite3BtreeEnter(p);
        rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
        sqlite3BtreeLeave(p);
    }
    return rc;
}
```

进一步调用sqlite3PagerCommitPhaseOne来提交数据:

```c
int sqlite3PagerCommitPhaseOne(
    Pager *pPager,                  /* Pager object */
    const char *zMaster,            /* If not NULL, the master journal name */
    int noSync                      /* True to omit the xSync on the db file */
)
{
    int rc = SQLITE_OK;             /* Return code */

    /* If a prior error occurred, report that error again. */
    if (NEVER(pPager->errCode)) return pPager->errCode;

    PAGERTRACE(("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n",
                pPager->zFilename, zMaster, pPager->dbSize));

    /* If no database changes have been made, return early. */
    if (pPager->eState < PAGER_WRITER_CACHEMOD) return SQLITE_OK;

    if (MEMDB)
    {
        /* If this is an in-memory db, or no pages have been written to, or this
        ** function has already been called, it is mostly a no-op.  However, any
        ** backup in progress needs to be restarted.
        */
        sqlite3BackupRestart(pPager->pBackup);
    }
    else
    {
        if (pagerUseWal(pPager))
        {
           // ...
        }
        else
        {
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
            PgHdr *pPg;
            if (!zMaster && isOpen(pPager->jfd) /* 日志处于打开状态 */
                && pPager->journalOff == jrnlBufferSize(pPager)
                && pPager->dbSize >= pPager->dbOrigSize /* 数据库增加了新内容 */
                && (0 == (pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0 == pPg->pDirty)
               )
            {
                /* Update the db file change counter via the direct-write method. The
                ** following call will modify the in-memory representation of page 1
                ** to include the updated change counter and then write page 1
                ** directly to the database file. Because of the atomic-write
                ** property of the host file-system, this is safe.
                */
                rc = pager_incr_changecounter(pPager, 1);
            }
            else
            {
                rc = sqlite3JournalCreate(pPager->jfd);
                if (rc == SQLITE_OK)
                {
                    rc = pager_incr_changecounter(pPager, 0);
                }
            }
#else
            rc = pager_incr_changecounter(pPager, 0);
#endif
            if (rc != SQLITE_OK) goto commit_phase_one_exit;

            /* Write the master journal name into the journal file. If a master
            ** journal file name has already been written to the journal file,
            ** or if zMaster is NULL (no master journal), then this call is a no-op.
            ** 将主日志的名称写入日志文件,如果主日志文件的名称已经被写入日志文件,又或者日志名称为空(没有主日志)
            ** 那么writeMasterJournal什么也不干.
            */
            rc = writeMasterJournal(pPager, zMaster);
            if (rc != SQLITE_OK) goto commit_phase_one_exit;
            /* 同步日志文件,并且将所有的脏页写回数据库 */
            rc = syncJournal(pPager, 0); /* 先将日志同步至磁盘表面 */
            if (rc != SQLITE_OK) goto commit_phase_one_exit;
			/* 将脏页写回数据库文件 */
            rc = pager_write_pagelist(pPager, sqlite3PcacheDirtyList(pPager->pPCache));
            if (rc != SQLITE_OK)
            {
                goto commit_phase_one_exit;
            }
            /* 将缓存中所有的页都标记为clean,因为脏页已经写回磁盘 */
            sqlite3PcacheCleanAll(pPager->pPCache);

            /* If the file on disk is not the same size as the database image,
            ** then use pager_truncate to grow or shrink the file here.
            */
            if (pPager->dbSize != pPager->dbFileSize)
            {
                Pgno nNew = pPager->dbSize - (pPager->dbSize == PAGER_MJ_PGNO(pPager));
                assert(pPager->eState == PAGER_WRITER_DBMOD);
                rc = pager_truncate(pPager, nNew);
                if (rc != SQLITE_OK) goto commit_phase_one_exit;
            }

            /* Finally, sync the database file. */
            if (!noSync)
            {
                rc = sqlite3PagerSync(pPager); /* 同步至磁盘 */
            }
            IOTRACE(("DBSYNC %p\n", pPager))
        }
    }

commit_phase_one_exit:
    if (rc == SQLITE_OK && !pagerUseWal(pPager))
    {
        pPager->eState = PAGER_WRITER_FINISHED;
    }
    return rc;
}
```

sqlite3PagerCommitPhaseOne函数之中,个人认为有一个步骤至关重要,那就是将数据写回磁盘.

其中最重要的一个函数为syncJournal,用于将日志同步到磁盘上面.

```c
static int syncJournal(Pager *pPager, int newHdr)
{
    int rc;                         /* Return code */

    rc = sqlite3PagerExclusiveLock(pPager);
    if (rc != SQLITE_OK) return rc;

    if (!pPager->noSync)
    {
        assert(!pPager->tempFile);
        if (isOpen(pPager->jfd) && pPager->journalMode != PAGER_JOURNALMODE_MEMORY)
        {
            const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd); /* 字符设备 */

            if (0 == (iDc & SQLITE_IOCAP_SAFE_APPEND))
            {
                i64 iNextHdrOffset;
                u8 aMagic[8];
                u8 zHeader[sizeof(aJournalMagic) + 4];

                memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
                put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);

                iNextHdrOffset = journalHdrOffset(pPager);
                rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
                if (rc == SQLITE_OK && 0 == memcmp(aMagic, aJournalMagic, 8))
                {
                    static const u8 zerobyte = 0;
                    rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
                }
                if (rc != SQLITE_OK && rc != SQLITE_IOERR_SHORT_READ)
                {
                    return rc;
                }

                if (pPager->fullSync && 0 == (iDc & SQLITE_IOCAP_SEQUENTIAL))
                {
                    PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));
                    IOTRACE(("JSYNC %p\n", pPager))
                    rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
                    if (rc != SQLITE_OK) return rc;
                }
                IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));
                rc = sqlite3OsWrite(
                         pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
                     );
                if (rc != SQLITE_OK) return rc;
            }
            if (0 == (iDc & SQLITE_IOCAP_SEQUENTIAL))
            {
                PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));
                IOTRACE(("JSYNC %p\n", pPager))
                rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags |
                                   (pPager->syncFlags == SQLITE_SYNC_FULL ? SQLITE_SYNC_DATAONLY : 0)
                                  );
                if (rc != SQLITE_OK) return rc;
            }

            pPager->journalHdr = pPager->journalOff;
            if (newHdr && 0 == (iDc & SQLITE_IOCAP_SAFE_APPEND))
            {
                pPager->nRec = 0;
                rc = writeJournalHdr(pPager);
                if (rc != SQLITE_OK) return rc;
            }
        }
        else
        {
            pPager->journalHdr = pPager->journalOff;
        }
    }

    /* Unless the pager is in noSync mode, the journal file was just
    ** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on
    ** all pages.
    */
    sqlite3PcacheClearSyncFlags(pPager->pPCache);
    pPager->eState = PAGER_WRITER_DBMOD;
    return SQLITE_OK;
}
```

另外一个核心函数是pager_write_pagelist,用于将数据库文件的脏页写回数据库.

```c
/*
** 将page写入磁盘
** @param pList 待写入的page
*/
static int pager_write_pagelist(Pager *pPager, PgHdr *pList)
{
    int rc = SQLITE_OK;                  /* Return code */

    /* If the file is a temp-file has not yet been opened, open it now. It
    ** is not possible for rc to be other than SQLITE_OK if this branch
    ** is taken, as pager_wait_on_lock() is a no-op for temp-files.
    */
    if (!isOpen(pPager->fd))
    {
        assert(pPager->tempFile && rc == SQLITE_OK);
        rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
    }

    /* Before the first write, give the VFS a hint of what the final
    ** file size will be.
    */
    assert(rc != SQLITE_OK || isOpen(pPager->fd));
    if (rc == SQLITE_OK && pPager->dbSize > pPager->dbHintSize)
    {
        /* 数据库大小 */
        sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
        sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);
        pPager->dbHintSize = pPager->dbSize;
    }

    while (rc == SQLITE_OK && pList)
    {
        Pgno pgno = pList->pgno;

        /* If there are dirty pages in the page cache with page numbers greater
        ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to
        ** make the file smaller (presumably by auto-vacuum code). Do not write
        ** any such pages to the file.
        **
        ** Also, do not write out any page that has the PGHDR_DONT_WRITE flag
        ** set (set by sqlite3PagerDontWrite()).
        */
        if (pgno <= pPager->dbSize && 0 == (pList->flags & PGHDR_DONT_WRITE))
        {
            /* 计算偏移量 */
            i64 offset = (pgno - 1) * (i64)pPager->pageSize; /* Offset to write */
            char *pData;                                   /* Data to write */

            assert((pList->flags & PGHDR_NEED_SYNC) == 0);
            if (pList->pgno == 1) pager_write_changecounter(pList);

            /* Encode the database */
            CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM, pData);

            /* Write out the page data. 将页的数据写入磁盘 */
            rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);

            /* If page 1 was just written, update Pager.dbFileVers to match
            ** the value now stored in the database file. If writing this
            ** page caused the database file to grow, update dbFileSize.
            */
            if (pgno == 1)
            {
                memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
            }
            if (pgno > pPager->dbFileSize)
            {
                pPager->dbFileSize = pgno; /* 更新文件大小 */
            }
            pPager->aStat[PAGER_STAT_WRITE]++;

            /* Update any backup objects copying the contents of this pager. */
            sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);

            PAGERTRACE(("STORE %d page %d hash(%08x)\n",
                        PAGERID(pPager), pgno, pager_pagehash(pList)));
            IOTRACE(("PGOUT %p %d\n", pPager, pgno));
            PAGER_INCR(sqlite3_pager_writedb_count);
        }
        else
        {
            PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));
        }
        pager_set_pagehash(pList);
        pList = pList->pDirty; /* 下一个page */
    }
    return rc;
}
```

## 第二阶段

第二阶段的工作其实也很简单,如果没有出错的话,直接对日志文件进行finalize操作(当然,大部分时候是直接删除或者截断日志文件).

核心函数为sqlite3BtreeCommitPhaseTwo:

```c
/*
** Commit the transaction currently in progress.
**
** 此函数实现两步提交中的第二步,sqlite3BtreeCommitPhaseOne()函数将所有信息都写入了磁盘,这一步要做
** 的是,删除或者阶段回滚日志.并且释放锁,收尾工作.
**
** 通常情况下,如果pager层想要删除(finalize)底层的日志文件的时候发生了错误,此函数返回一个错误,并且上层将会尝试
** 回滚操作,然而,如果第二个参数不是0,那么此b-tree事务是多文件事务的一部分,这种情况下,事务已经被提交
** (通过删除主日志文件),并且调用者已经忽略了此函数的返回值,因此如果错误发生在pager层,重置b-tree的内部
** 状态,来提示写事务已经被关闭,这是很安全的,因为pager层将转换到错误状态.
**
** This will release the write lock on the database file.  If there
** are no active cursors, it also releases the read lock.
*/
int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup)
{

    if (p->inTrans == TRANS_NONE) return SQLITE_OK;
    sqlite3BtreeEnter(p);
    btreeIntegrity(p);

    /* If the handle has a write-transaction open, commit the shared-btrees
    ** transaction and set the shared state to TRANS_READ.
    */
    if (p->inTrans == TRANS_WRITE)
    {
        int rc;
        BtShared *pBt = p->pBt;
        rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);
        if (rc != SQLITE_OK && bCleanup == 0)
        {
            sqlite3BtreeLeave(p);
            return rc;
        }
        pBt->inTransaction = TRANS_READ;
    }

    btreeEndTransaction(p);
    sqlite3BtreeLeave(p);
    return SQLITE_OK;
}
```

在一些检查通过之后,调用sqlite3PagerCommitPhaseTwo:

```c
/*
** 当此函数被调用的时候,数据库文件已经完全被更新来反应当前事务造成的改变,日志文件存在于文件系统.
** 如果在这个点发生了错误,将会导致回滚.
**
** This function finalizes the journal file, either by deleting,
** truncating or partially zeroing it, so that it cannot be used
** for hot-journal rollback. Once this is done the transaction is
** irrevocably committed.
**
** If an error occurs, an IO error code is returned and the pager
** moves into the error state. Otherwise, SQLITE_OK is returned.
*/
int sqlite3PagerCommitPhaseTwo(Pager *pPager)
{
    int rc = SQLITE_OK;                  /* Return code */

    /* This routine should not be called if a prior error has occurred.
    ** But if (due to a coding error elsewhere in the system) it does get
    ** called, just return the same error code without doing anything. */
    if (NEVER(pPager->errCode)) return pPager->errCode;

    /* An optimization. If the database was not actually modified during
    ** this transaction, the pager is running in exclusive-mode and is
    ** using persistent journals, then this function is a no-op.
    **
    ** The start of the journal file currently contains a single journal
    ** header with the nRec field set to 0. If such a journal is used as
    ** a hot-journal during hot-journal rollback, 0 changes will be made
    ** to the database file. So there is no need to zero the journal
    ** header. Since the pager is in exclusive mode, there is no need
    ** to drop any locks either.
    */
    if (pPager->eState == PAGER_WRITER_LOCKED
        && pPager->exclusiveMode
        && pPager->journalMode == PAGER_JOURNALMODE_PERSIST
       )
    {
        pPager->eState = PAGER_READER; /* 需要释放锁 */
        return SQLITE_OK;
    }

    PAGERTRACE(("COMMIT %d\n", PAGERID(pPager)));
    rc = pager_end_transaction(pPager, pPager->setMaster);
    return pager_error(pPager, rc);
}
```

最终调用pager_end_transaction来结束事务.

```c
/*
** This routine ends a transaction. A transaction is usually ended by
** either a COMMIT or a ROLLBACK operation. This routine may be called
** after rollback of a hot-journal, or if an error occurs while opening
** the journal file or writing the very first journal-header of a
** database transaction.
** 此函数完成事务,一个事务的终结,要么通过COMMIT,要么通过ROLLBACK.
**
** This routine is never called in PAGER_ERROR state. If it is called
** in PAGER_NONE or PAGER_SHARED state and the lock held is less
** exclusive than a RESERVED lock, it is a no-op.
** 此函数永远不会在pager处于PAGER_ERROR的时候被调用,如果它处于PAGER_NONE或者PAGER_SHARED,
** 而且锁的级别低于RESERVED,那么什么也不干.
**
** Otherwise, any active savepoints are released.
** 否则的话,所有处于active状态的savepoints将会被释放.
**
** If the journal file is open, then it is "finalized". Once a journal
** file has been finalized it is not possible to use it to roll back a
** transaction. Nor will it be considered to be a hot-journal by this
** or any other database connection. Exactly how a journal is finalized
** depends on whether or not the pager is running in exclusive mode and
** the current journal-mode (Pager.journalMode value), as follows:
**
**   journalMode==MEMORY
**     日志文件描述符只需要简单关闭即可,这个会销毁内存日志.
**
**   journalMode==TRUNCATE
**     日志文件需要被截断成0字节.
**
**   journalMode==PERSIST
**     The first 28 bytes of the journal file are zeroed. This invalidates
**     the first journal header in the file, and hence the entire journal
**     file. An invalid journal file cannot be rolled back.
**     日志文件的头28个字节需要被清零,从而保证日志文件无效.
**
**   journalMode==DELETE
**     The journal file is closed and deleted using sqlite3OsDelete().
**
**     If the pager is running in exclusive mode, this method of finalizing
**     the journal file is never used. Instead, if the journalMode is
**     DELETE and the pager is in exclusive mode, the method described under
**     journalMode==PERSIST is used instead.
**
** After the journal is finalized, the pager moves to PAGER_READER state.
** If running in non-exclusive rollback mode, the lock on the file is
** downgraded to a SHARED_LOCK.
** 在日志被finalize之后,pager切换到PAGER_READER状态.
**
** 如果没有错误发生,返回SQLITE_OK,如果在执行IO操作来删除日志文件/解锁数据库的时候IO发生错误
** 错误码将返回给调用者.如果删除日志文件操作失败,代码仍然尝试解锁数据库文件如果它不处于独占模式的话.
** 如果解锁操作也失败了,那么第一个错误对应的第一个错误码(删除日志文件遭遇的)将会被返回.
*/
static int pager_end_transaction(Pager *pPager, int hasMaster)
{
    int rc = SQLITE_OK;      /* Error code from journal finalization operation */
    int rc2 = SQLITE_OK;     /* Error code from db file unlock operation */

    /* Do nothing if the pager does not have an open write transaction
    ** or at least a RESERVED lock. This function may be called when there
    ** is no write-transaction active but a RESERVED or greater lock is
    ** held under two circumstances:
    **
    **   1. After a successful hot-journal rollback, it is called with
    **      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.
    **
    **   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE
    **      lock switches back to locking_mode=normal and then executes a
    **      read-transaction, this function is called with eState==PAGER_READER
    **      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.
    */
    if (pPager->eState < PAGER_WRITER_LOCKED && pPager->eLock < RESERVED_LOCK)
    {
        return SQLITE_OK;
    }

    releaseAllSavepoints(pPager); /* 释放掉所有的savepoint */
    assert(isOpen(pPager->jfd) || pPager->pInJournal == 0);
    if (isOpen(pPager->jfd)) /* 日志文件处于打开的状态 */
    {
        /* Finalize the journal file. */
        if (sqlite3IsMemJournal(pPager->jfd)) /* 内存日志 */
        {
            assert(pPager->journalMode == PAGER_JOURNALMODE_MEMORY);
            sqlite3OsClose(pPager->jfd); /* 关闭日志文件 */
        }
        else if (pPager->journalMode == PAGER_JOURNALMODE_TRUNCATE)
        {
            if (pPager->journalOff == 0)
            {
                rc = SQLITE_OK;
            }
            else
            {
                rc = sqlite3OsTruncate(pPager->jfd, 0); /* 截断日志文件 */
            }
            pPager->journalOff = 0;
        }
        else if (pPager->journalMode == PAGER_JOURNALMODE_PERSIST
                 || (pPager->exclusiveMode && pPager->journalMode != PAGER_JOURNALMODE_WAL)
                )
        {
            rc = zeroJournalHdr(pPager, hasMaster);
            pPager->journalOff = 0;
        }
        else
        {
            /* This branch may be executed with Pager.journalMode==MEMORY if
            ** a hot-journal was just rolled back. In this case the journal
            ** file should be closed and deleted. If this connection writes to
            ** the database file, it will do so using an in-memory journal.
            */
            assert(pPager->journalMode == PAGER_JOURNALMODE_DELETE
                   || pPager->journalMode == PAGER_JOURNALMODE_MEMORY
                   || pPager->journalMode == PAGER_JOURNALMODE_WAL
                  );
            sqlite3OsClose(pPager->jfd); /* 关闭日志文件 */
            if (!pPager->tempFile)
            {
                rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0); /* 删除临时文件 */
            }
        }
    }

    sqlite3BitvecDestroy(pPager->pInJournal); /* 销毁位图 */
    pPager->pInJournal = 0;
    pPager->nRec = 0;
    sqlite3PcacheCleanAll(pPager->pPCache);
    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);

    if (pagerUseWal(pPager))
    {
        /* Drop the WAL write-lock, if any. Also, if the connection was in
        ** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE
        ** lock held on the database file.
        */
        rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
        assert(rc2 == SQLITE_OK);
    }
    if (!pPager->exclusiveMode
        && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0)))
    {
        rc2 = pagerUnlockDb(pPager, SHARED_LOCK);
        pPager->changeCountDone = 0;
    }
    pPager->eState = PAGER_READER;
    pPager->setMaster = 0;
    return (rc == SQLITE_OK ? rc2 : rc);
}
```

# 数据库回滚浅析

Btree模块向外提供了接口sqlite3BtreeRollback,用于回滚事务.

```c
/*
** Rollback the transaction in progress.  All cursors will be
** invalided by this operation.  Any attempt to use a cursor
** that was open at the beginning of this operation will result
** in an error.
** 回滚事务,此操作中的所有游标都将变得无效.
**
** This will release the write lock on the database file.  If there
** are no active cursors, it also releases the read lock.
*/
int sqlite3BtreeRollback(Btree *p, int tripCode)
{
    int rc;
    BtShared *pBt = p->pBt;
    MemPage *pPage1;

    sqlite3BtreeEnter(p);
    if (tripCode == SQLITE_OK)
    {
        rc = tripCode = saveAllCursors(pBt, 0, 0);
    }
    else
    {
        rc = SQLITE_OK;
    }
    if (tripCode)
    {
        sqlite3BtreeTripAllCursors(p, tripCode);
    }
    btreeIntegrity(p);

    if (p->inTrans == TRANS_WRITE) /* 存在写事务 */
    {
        int rc2;
        rc2 = sqlite3PagerRollback(pBt->pPager); /* 执行回滚操作 */
        if (rc2 != SQLITE_OK)
        {
            rc = rc2;
        }

        /* The rollback may have destroyed the pPage1->aData value.  So
        ** call btreeGetPage() on page 1 again to make
        ** sure pPage1->aData is set correctly. */
        if (btreeGetPage(pBt, 1, &pPage1, 0) == SQLITE_OK)
        {
            int nPage = get4byte(28 + (u8*)pPage1->aData);
            testcase(nPage == 0);
            if (nPage == 0) sqlite3PagerPagecount(pBt->pPager, &nPage);
            testcase(pBt->nPage != nPage);
            pBt->nPage = nPage; /* 重新读取页数目 */
            releasePage(pPage1);
        }
        pBt->inTransaction = TRANS_READ;
    }
    btreeEndTransaction(p);
    sqlite3BtreeLeave(p);
    return rc;
}
```

sqlite3BtreeRollback做了一些常规的操作之后,会调用pager模块的sqlite3PagerRollback来执行回滚.

```c
/*
** 如果一个写事务打开,那么所有在这个事务中的更改都将被回滚,并且当前的写事务将会被关闭.pager将会
** 回滚到PAGER_READER状态,如果成功的话,如果失败了,将转换到PAGER_ERROR状态.
** 如果当此函数被调用时,pager已经处在PAGER_ERROR状态,立刻返回Pager.errCode,什么也不做.
**
** Otherwise, in rollback mode, this function performs two functions:
** 否则,在回滚模式中,此函数做两件事情:
**
**   1) 回滚日志文件,还原全部的数据库文件以及内存的缓存页到事务开始时的状态;
**
**   2) 销毁日志文件,使得日志文件不能再用于回滚.
**
** 销毁日志文件只有当回滚成功了,才能执行.
**
** In WAL mode, all cache-entries containing data modified within the
** current transaction are either expelled from the cache or reverted to
** their pre-transaction state by re-reading data from the database or
** WAL files. The WAL transaction is then closed.
** 在WAL模式中,在当前事务中被修改过的所有包含数据的缓存记录要么从缓存中删除,要么恢复到事务
** 之前的状态(通过重新从数据库或者WAL文件中读取数据),然后关闭WAL事务.
*/
int sqlite3PagerRollback(Pager *pPager)
{
    int rc = SQLITE_OK;                  /* Return code */
    PAGERTRACE(("ROLLBACK %d\n", PAGERID(pPager)));

    /* PagerRollback() is a no-op if called in READER or OPEN state. If
    ** the pager is already in the ERROR state, the rollback is not
    ** attempted here. Instead, the error code is returned to the caller.
    */
    if (pPager->eState == PAGER_ERROR) return pPager->errCode;
    if (pPager->eState <= PAGER_READER) return SQLITE_OK;

    if (pagerUseWal(pPager))
    {
		// ...
    }
    else if (!isOpen(pPager->jfd) || pPager->eState == PAGER_WRITER_LOCKED)
    { /* 如果日志处于关闭状态或者pager状态处于WRITER_LOCKED,要么说明日志由于某种原因没有打开
       ** 总之就是还没有来得及往日志中写数据.
       */
        int eState = pPager->eState;
        /* 销毁日志 */
        rc = pager_end_transaction(pPager, 0);
        if (!MEMDB && eState > PAGER_WRITER_LOCKED)
        {
            /* This can happen using journal_mode=off. Move the pager to the error
            ** state to indicate that the contents of the cache may not be trusted.
            ** Any active readers will get SQLITE_ABORT.
            */
            pPager->errCode = SQLITE_ABORT;
            pPager->eState = PAGER_ERROR;
            return rc;
        }
    }
    else /* 已经往日志文件中写了数据 */
    {
        rc = pager_playback(pPager, 0); /* 回滚改动的页的数据 */
    }

    /* If an error occurs during a ROLLBACK, we can no longer trust the pager
    ** cache. So call pager_error() on the way out to make any error persistent.
    */
    return pager_error(pPager, rc);
}
```

我们来看一下核心函数pager_palyback:

```c
/*
** 回放日志,从而将数据库文件恢复到我们进行更改之前的状态.
**
** 日志文件的格式如下:
**
**  (1)  8 byte prefix.  A copy of aJournalMagic[].
**  (2)  4 byte big-endian integer which is the number of valid page records
**       in the journal.  If this value is 0xffffffff, then compute the
**       number of page records from the journal size.
**      4字节大端的整数,用于表示日志中有效的页记录的数目,如果这个值为0xffffffff,那么页记录
**      的数目,需要通过日志大小来计算.
**  (3)  4 byte big-endian integer which is the initial value for the
**       sanity checksum.
**  (4)  4 byte integer which is the number of pages to truncate the
**       database to during a rollback.
**  (5)  4 byte big-endian integer which is the sector size.  The header
**       is this many bytes in size.
**  (6)  4 byte big-endian integer which is the page size.
**  (7)  zero padding out to the next sector size.
**  (8)  Zero or more pages instances, each as follows:
**        +  4 byte page number.
**        +  pPager->pageSize bytes of data.
**        +  4 byte checksum
**
** 当我们说道日志头部的时候,我们说的是以上的前7个条目,日志里的每一条记录都是第8个条目的实例.
**
** Call the value from the second bullet "nRec".  nRec is the number of
** valid page entries in the journal.  In most cases, you can compute the
** value of nRec from the size of the journal file.  But if a power
** failure occurred while the journal was being written, it could be the
** case that the size of the journal file had already been increased but
** the extra entries had not yet made it safely to disk.  In such a case,
** the value of nRec computed from the file size would be too large.  For
** that reason, we always use the nRec value in the header.
**
** If the nRec value is 0xffffffff it means that nRec should be computed
** from the file size.  This value is used when the user selects the
** no-sync option for the journal.  A power failure could lead to corruption
** in this case.  But for things like temporary table (which will be
** deleted when the power is restored) we don't care.
**
** If the file opened as the journal file is not a well-formed
** journal file then all pages up to the first corrupted page are rolled
** back (or no pages if the journal header is corrupted). The journal file
** is then deleted and SQLITE_OK returned, just as if no corruption had
** been encountered.
**
** If an I/O or malloc() error occurs, the journal-file is not deleted
** and an error code is returned.
**
** The isHot parameter indicates that we are trying to rollback a journal
** that might be a hot journal.  Or, it could be that the journal is
** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.
** If the journal really is hot, reset the pager cache prior rolling
** back any content.  If the journal is merely persistent, no reset is
** needed.
*/
static int pager_playback(Pager *pPager, int isHot)
{
    sqlite3_vfs *pVfs = pPager->pVfs;
    i64 szJ;                 /* Size of the journal file in bytes */
    u32 nRec;                /* Number of Records in the journal */
    u32 u;                   /* Unsigned loop counter */
    Pgno mxPg = 0;           /* Size of the original file in pages */
    int rc;                  /* Result code of a subroutine */
    int res = 1;             /* Value returned by sqlite3OsAccess() */
    char *zMaster = 0;       /* Name of master journal file if any */
    int needPagerReset;      /* True to reset page prior to first page rollback */

    /* 计算日志中有多少条记录,如果日志为空的话,可以早点终止. */
    assert(isOpen(pPager->jfd));
    rc = sqlite3OsFileSize(pPager->jfd, &szJ); /* 日志文件大小 */
    if (rc != SQLITE_OK)
    {
        goto end_playback;
    }

    /* Read the master journal name from the journal, if it is present.
    ** If a master journal file name is specified, but the file is not
    ** present on disk, then the journal is not hot and does not need to be
    ** played back.
    ** 从日志中读取主日志文件的名称,如果它存在的话,如果主日志文件的名称指定了,但是没有在磁盘上找到文件.
    ** 那么说明日志不是hot,不需要回滚.
    */
    zMaster = pPager->pTmpSpace;
    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname + 1);
    if (rc == SQLITE_OK && zMaster[0])
    {
        rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);
    }
    zMaster = 0;
    if (rc != SQLITE_OK || !res)
    {
        goto end_playback;
    }
    pPager->journalOff = 0;
    needPagerReset = isHot;

    /* This loop terminates either when a readJournalHdr() or
    ** pager_playback_one_page() call returns SQLITE_DONE or an IO error
    ** occurs.
    */
    while (1)
    {
        /* Read the next journal header from the journal file.  If there are
        ** not enough bytes left in the journal file for a complete header, or
        ** it is corrupted, then a process must have failed while writing it.
        ** This indicates nothing more needs to be rolled back.
        ** 从日志文件中读取下一条日志头部,如果日志文件剩余的空间不足矣容纳一个完整的头部,或者
        ** 日志文件损坏,那么说明当进程在写这个数据的时候是挂了,这意味着我们无需回滚.
        */
        rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
        if (rc != SQLITE_OK)
        {
            if (rc == SQLITE_DONE)
            {
                rc = SQLITE_OK;
            }
            goto end_playback;
        }

        /*
        ** 如果nRec为0xffffffff,那么说明这个日志是一个处于no-sync模式的进程创建的,这意味着
        ** 日志文件剩余内容都是日志记录,没有更多的日志头.
        */
        if (nRec == 0xffffffff)
        {
            assert(pPager->journalOff == JOURNAL_HDR_SZ(pPager));
            nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager)) / JOURNAL_PG_SZ(pPager));
        }

        /* If nRec is 0 and this rollback is of a transaction created by this
        ** process and if this is the final header in the journal, then it means
        ** that this part of the journal was being filled but has not yet been
        ** synced to disk.  Compute the number of pages based on the remaining
        ** size of the file.
        ** 如果nRec为0,并且事务的回滚通过此进程,如果这是日志的最后一个头部,这意味着
        ** 日志的这部分还没有来得及同步到磁盘,通过文件剩余部分的大小来计算page的数目.
        **
        ** The third term of the test was added to fix ticket #2565.
        ** When rolling back a hot journal, nRec==0 always means that the next
        ** chunk of the journal contains zero pages to be rolled back.  But
        ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in
        ** the journal, it means that the journal might contain additional
        ** pages that need to be rolled back and that the number of pages
        ** should be computed based on the journal file size.
        */
        if (nRec == 0 && !isHot &&
            pPager->journalHdr + JOURNAL_HDR_SZ(pPager) == pPager->journalOff)
        { /* 最后一个日志头部 */
            nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));
        }

        /* If this is the first header read from the journal, truncate the
        ** database file back to its original size.
        ** 如果这是从日志中读取的第一个头部,截断数据库文件到它原来的大小.
        */
        if (pPager->journalOff == JOURNAL_HDR_SZ(pPager))
        {
            rc = pager_truncate(pPager, mxPg);
            if (rc != SQLITE_OK)
            {
                goto end_playback;
            }
            pPager->dbSize = mxPg;
        }

        /* Copy original pages out of the journal and back into the
        ** database file and/or page cache.
        ** 从日志文件中拷贝原本的页数据到数据库文件/页缓存
        */
        for (u = 0; u < nRec; u++)
        {
            if (needPagerReset)
            {
                pager_reset(pPager);
                needPagerReset = 0;
            }
            /* 一个page一个page地进行回滚 */
            rc = pager_playback_one_page(pPager, &pPager->journalOff, 0, 1, 0);
            if (rc != SQLITE_OK)
            {
                if (rc == SQLITE_DONE) /* 已经还原完成 */
                {
                    pPager->journalOff = szJ;
                    break;
                }
                else if (rc == SQLITE_IOERR_SHORT_READ)
                {
                    /* If the journal has been truncated, simply stop reading and
                    ** processing the journal. This might happen if the journal was
                    ** not completely written and synced prior to a crash.  In that
                    ** case, the database should have never been written in the
                    ** first place so it is OK to simply abandon the rollback. */
                    rc = SQLITE_OK;
                    goto end_playback;
                }
                else
                {
                    /* If we are unable to rollback, quit and return the error
                    ** code.  This will cause the pager to enter the error state
                    ** so that no further harm will be done.  Perhaps the next
                    ** process to come along will be able to rollback the database.
                    */
                    goto end_playback;
                }
            }
        }
    }

end_playback:
    /* Following a rollback, the database file should be back in its original
    ** state prior to the start of the transaction, so invoke the
    ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the
    ** assertion that the transaction counter was modified.
    */

    /* If this playback is happening automatically as a result of an IO or
    ** malloc error that occurred after the change-counter was updated but
    ** before the transaction was committed, then the change-counter
    ** modification may just have been reverted. If this happens in exclusive
    ** mode, then subsequent transactions performed by the connection will not
    ** update the change-counter at all. This may lead to cache inconsistency
    ** problems for other processes at some point in the future. So, just
    ** in case this has happened, clear the changeCountDone flag now.
    */
    pPager->changeCountDone = pPager->tempFile;

    if (rc == SQLITE_OK)
    {
        zMaster = pPager->pTmpSpace;
        rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname + 1);
        testcase(rc != SQLITE_OK);
    }
    if (rc == SQLITE_OK
        && (pPager->eState >= PAGER_WRITER_DBMOD || pPager->eState == PAGER_OPEN))
    {
        rc = sqlite3PagerSync(pPager);
    }
    if (rc == SQLITE_OK)
    {
        rc = pager_end_transaction(pPager, zMaster[0] != '\0');
        testcase(rc != SQLITE_OK);
    }
    if (rc == SQLITE_OK && zMaster[0] && res)
    {
        /* If there was a master journal and this routine will return success,
        ** see if it is possible to delete the master journal.
        */
        /* 最终尝试删除日志文件 */
        rc = pager_delmaster(pPager, zMaster);
        testcase(rc != SQLITE_OK);
    }

    /* The Pager.sectorSize variable may have been updated while rolling
    ** back a journal created by a process with a different sector size
    ** value. Reset it to the correct value for this process.
    */
    setSectorSize(pPager);
    return rc;
}
```

# 修改页的标记

每当要修改数据库中的某一页的时候,需要调用sqlite3PagerWrite来告知pager层.pager层在修改开始之前,先将原本的数据写入日志,方便后面还原.

```c
/*
** Mark a data page as writeable. This routine must be called before
** making changes to a page. The caller must check the return value
** of this function and be careful not to change any page data unless
** this routine returns SQLITE_OK.
**
** The difference between this function and pager_write() is that this
** function also deals with the special case where 2 or more pages
** fit on a single disk sector. In this case all co-resident pages
** must have been written to the journal file before returning.
**
** If an error occurs, SQLITE_NOMEM or an IO error code is returned
** as appropriate. Otherwise, SQLITE_OK.
** 将数据库的页标记为可写
*/
int sqlite3PagerWrite(DbPage *pDbPage)
{
    int rc = SQLITE_OK;

    PgHdr *pPg = pDbPage;
    Pager *pPager = pPg->pPager;
    /* 计算每一个扇区可以包含多少page */
    Pgno nPagePerSector = (pPager->sectorSize / pPager->pageSize);

    if (nPagePerSector > 1) /* 1个扇区可以包含多个page,写入日志文件都是以扇区为单位,所以这里要写入多个page */
    {
        /* 数据库文件总页数 */
        Pgno nPageCount;          /* Total number of pages in database file */
        /* pPg所在扇区的第一个page的页号 */
        Pgno pg1;                 /* First page of the sector pPg is located on. */
        /* 要写入的page的个数 */
        int nPage = 0;            /* Number of pages starting at pg1 to journal */
        int ii;                   /* Loop counter */
        int needSync = 0;         /* True if any page has PGHDR_NEED_SYNC */

        /* Set the doNotSyncSpill flag to 1. This is because we cannot allow
        ** a journal header to be written between the pages journaled by
        ** this function.
        */
        pPager->doNotSyncSpill++;

        /* This trick assumes that both the page-size and sector-size are
        ** an integer power of 2. It sets variable pg1 to the identifier
        ** of the first page of the sector pPg is located on.
        ** 我们假定page大小和sector大小都是2的幂次,
        ** pg1设置为pPg所在扇区的第一个page的页号
        */
        pg1 = ((pPg->pgno - 1) & ~(nPagePerSector - 1)) + 1;

        nPageCount = pPager->dbSize;
        if (pPg->pgno > nPageCount) /* 新页 */
        {
            nPage = (pPg->pgno - pg1) + 1; /* 从pg1写到pPg->pgno即可 */
        }
        else if ((pg1 + nPagePerSector - 1) > nPageCount) /* 从pg1开始,剩余量不足一个sector */
        {
            /* 写到数据库末尾所在的页即可 */
            nPage = nPageCount + 1 - pg1;
        }
        else
        {
            nPage = nPagePerSector; /* 否则写满完整的一个sector */
        }

        for (ii = 0; ii < nPage && rc == SQLITE_OK; ii++)
        {
            Pgno pg = pg1 + ii;
            PgHdr *pPage;
			/* 如果pg代表的页没有在日志文件中,但是上层又需要对这一页进行修改 */
            if (pg == pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg))
            {
                if (pg != PAGER_MJ_PGNO(pPager))
                {
                    rc = sqlite3PagerGet(pPager, pg, &pPage); /* 获取page */
                    if (rc == SQLITE_OK)
                    {
                        /* 写入日志文件 */
                        rc = pager_write(pPage);
                        if (pPage->flags & PGHDR_NEED_SYNC)
                        {
                            needSync = 1;
                        }
                        sqlite3PagerUnref(pPage);
                    }
                }
            }
            else if ((pPage = pager_lookup(pPager, pg)) != 0)
            {
                if (pPage->flags & PGHDR_NEED_SYNC)
                {
                    needSync = 1;
                }
                sqlite3PagerUnref(pPage);
            }
        }

        /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages
        ** starting at pg1, then it needs to be set for all of them. Because
        ** writing to any of these nPage pages may damage the others, the
        ** journal file must contain sync()ed copies of all of them
        ** before any of them can be written out to the database file.
        */
        if (rc == SQLITE_OK && needSync)
        {
            assert(!MEMDB);
            for (ii = 0; ii < nPage; ii++)
            {
                PgHdr *pPage = pager_lookup(pPager, pg1 + ii);
                if (pPage)
                {
                    pPage->flags |= PGHDR_NEED_SYNC;
                    sqlite3PagerUnref(pPage);
                }
            }
        }
        pPager->doNotSyncSpill--;
    }
    else /* 1个扇区只能包含1页或者包含不了一页 */
    {
        rc = pager_write(pDbPage);
    }
    return rc;
}
```

由于数据库文件的写入往往以扇区为单位才更加高效.sqlite3PagerWrite先计算一个扇区包含多少page,一次修改,需要将对应page所在扇区的数据都写入日志文件中去.

```c
/*
** Mark a single data page as writeable. The page is written into the
** main journal or sub-journal as required. If the page is written into
** one of the journals, the corresponding bit is set in the
** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs
** of any open savepoints as appropriate.
** 将一个单独的数据页(page)标记为可写,页会根据要求写入主日志/sub日志.如果页被写入以上任意一个日志.
** 那么Pager.pInJournal位图将会被标记,表示此page已经写入日志.
*/
static int pager_write(PgHdr *pPg)
{
    void *pData = pPg->pData;
    Pager *pPager = pPg->pPager;
    int rc = SQLITE_OK;

    /* This routine is not called unless a write-transaction has already
    ** been started. The journal file may or may not be open at this point.
    ** It is never called in the ERROR state.
    */

    /* If an error has been previously detected, report the same error
    ** again. This should not happen, but the check provides robustness. */
    if (NEVER(pPager->errCode))  return pPager->errCode;

    /* Higher-level routines never call this function if database is not
    ** writable.  But check anyway, just for robustness. */
    if (NEVER(pPager->readOnly)) return SQLITE_PERM;

    CHECK_PAGE(pPg);

    /* The journal file needs to be opened. Higher level routines have already
    ** obtained the necessary locks to begin the write-transaction, but the
    ** rollback journal might not yet be open. Open it now if this is the case.
    **
    ** This is done before calling sqlite3PcacheMakeDirty() on the page.
    ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then
    ** an error might occur and the pager would end up in WRITER_LOCKED state
    ** with pages marked as dirty in the cache.
    */
    if (pPager->eState == PAGER_WRITER_LOCKED)
    {
        rc = pager_open_journal(pPager);
        if (rc != SQLITE_OK) return rc;
    }

    /* Mark the page as dirty.  If the page has already been written
    ** to the journal then we can return right away.
    */
    sqlite3PcacheMakeDirty(pPg);
    if (pageInJournal(pPg) && !subjRequiresPage(pPg))
    {
        assert(!pagerUseWal(pPager));
    }
    else
    {

        /* The transaction journal now exists and we have a RESERVED or an
        ** EXCLUSIVE lock on the main database file.  Write the current page to
        ** the transaction journal if it is not there already.
        */
        if (!pageInJournal(pPg) && !pagerUseWal(pPager))
        {
            assert(pagerUseWal(pPager) == 0);
            /* pPg->pgno <= pPager->dbOrigSize表示只是修改 */
            if (pPg->pgno <= pPager->dbOrigSize && isOpen(pPager->jfd))
            {
                u32 cksum;
                char *pData2;
                i64 iOff = pPager->journalOff;

                /* We should never write to the journal file the page that
                ** contains the database locks.  The following assert verifies
                ** that we do not. */
                assert(pPg->pgno != PAGER_MJ_PGNO(pPager));

                CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2);
                cksum = pager_cksum(pPager, (u8*)pData2);

                /* Even if an IO or diskfull error occurs while journalling the
                ** page in the block above, set the need-sync flag for the page.
                ** Otherwise, when the transaction is rolled back, the logic in
                ** playback_one_page() will think that the page needs to be restored
                ** in the database file. And if an IO error occurs while doing so,
                ** then corruption may follow.
                */
                pPg->flags |= PGHDR_NEED_SYNC;
                /* 日志中写入页号 */
                rc = write32bits(pPager->jfd, iOff, pPg->pgno);
                if (rc != SQLITE_OK) return rc;
                /* 写入内容 */
                rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff + 4);
                if (rc != SQLITE_OK) return rc;
                /* 写入checksum */
                rc = write32bits(pPager->jfd, iOff + pPager->pageSize + 4, cksum);
                if (rc != SQLITE_OK) return rc;

                IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno,
                         pPager->journalOff, pPager->pageSize));
                PAGER_INCR(sqlite3_pager_writej_count);
                PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",
                            PAGERID(pPager), pPg->pgno,
                            ((pPg->flags & PGHDR_NEED_SYNC) ? 1 : 0), pager_pagehash(pPg)));
                /* 记录偏移 */
                pPager->journalOff += 8 + pPager->pageSize;
                /* 记录数目+1 */
                pPager->nRec++;
                assert(pPager->pInJournal != 0);
                /* 标记bitmap,表示页已经存在于日志中 */
                rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
                testcase(rc == SQLITE_NOMEM);
                assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
                rc |= addToSavepointBitvecs(pPager, pPg->pgno);
                if (rc != SQLITE_OK)
                {
                    assert(rc == SQLITE_NOMEM);
                    return rc;
                }
            }
            else
            {
                if (pPager->eState != PAGER_WRITER_DBMOD)
                {
                    pPg->flags |= PGHDR_NEED_SYNC;
                }
                PAGERTRACE(("APPEND %d page %d needSync=%d\n",
                            PAGERID(pPager), pPg->pgno,
                            ((pPg->flags & PGHDR_NEED_SYNC) ? 1 : 0)));
            }
        }

        /* If the statement journal is open and the page is not in it,
        ** then write the current page to the statement journal.  Note that
        ** the statement journal format differs from the standard journal format
        ** in that it omits the checksums and the header.
        */
        if (subjRequiresPage(pPg))
        {
            rc = subjournalPage(pPg);
        }
    }

    /* 更新数据库的大小,这一点很重要 */
    if (pPager->dbSize < pPg->pgno)
    {
        pPager->dbSize = pPg->pgno;
    }
    return rc;
}
```

