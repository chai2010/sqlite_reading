pager模块是SQLite相对较为底层的模块.它使用操作系统提供的函数,直接操作磁盘数据.上层的btree模块依赖于此模块,它很好地帮助上层模块屏蔽了底层的细节.

一个连接可以有多个数据库对象---一个主要的数据库以及附加的数据库,每一个数据库对象有一个B-tree对象,一个B-tree有一个pager对象.





# 数据结构

## sqlite3_file

sqlite3_file是文件接口的抽象.

```c
/*
** CAPI3REF: OS Interface Open File Handle
**
** An [sqlite3_file] object represents an open file in the
** [sqlite3_vfs | OS interface layer].  Individual OS interface
** implementations will
** want to subclass this object by appending additional fields
** for their own use.  The pMethods entry is a pointer to an
** [sqlite3_io_methods] object that defines methods for performing
** I/O operations on the open file.
*/
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file /* sqlite对文件的抽象 */
{
    const struct sqlite3_io_methods *pMethods;  /* Methods for an open file */
};
```

## sqlite3_io_methods

因为不同操作系统的对应操作函数可能不一致,sqlite3实现了一个抽象层,用于封装底层的差异,对上提供统一的接口.

```c
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods /* io的操作方法 */
{
    int iVersion;
    int (*xClose)(sqlite3_file*);
    int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
    int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
    int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
    int (*xSync)(sqlite3_file*, int flags);
    int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
    int (*xLock)(sqlite3_file*, int);
    int (*xUnlock)(sqlite3_file*, int);
    int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
    int (*xFileControl)(sqlite3_file*, int op, void *pArg);
    int (*xSectorSize)(sqlite3_file*);
    int (*xDeviceCharacteristics)(sqlite3_file*);
    /* Methods above are valid for version 1 */
    int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
    int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);
    void (*xShmBarrier)(sqlite3_file*);
    int (*xShmUnmap)(sqlite3_file*, int deleteFlag);
    /* Methods above are valid for version 2 */
    /* Additional methods may be added in future releases */
};
```

## sqlite3_vfs

sqlite3_vfs是对虚拟文件系统的抽象.

```c
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs
{
    int iVersion;            /* Structure version number (currently 3) */
    int szOsFile;            /* Size of subclassed sqlite3_file */
    int mxPathname;          /* Maximum file pathname length */
    sqlite3_vfs *pNext;      /* Next registered VFS */
    const char *zName;       /* Name of this virtual file system */
    void *pAppData;          /* Pointer to application-specific data */
    int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
                 int flags, int *pOutFlags);
    int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
    int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
    int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
    void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
    void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
    void (*(*xDlSym)(sqlite3_vfs*, void*, const char *zSymbol))(void);
    void (*xDlClose)(sqlite3_vfs*, void*);
    int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
    int (*xSleep)(sqlite3_vfs*, int microseconds);
    int (*xCurrentTime)(sqlite3_vfs*, double*);
    int (*xGetLastError)(sqlite3_vfs*, int, char *);
    /*
    ** The methods above are in version 1 of the sqlite_vfs object
    ** definition.  Those that follow are added in version 2 or later
    */
    int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);
    /*
    ** The methods above are in versions 1 and 2 of the sqlite_vfs object.
    ** Those below are for version 3 and greater.
    */
    int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
    sqlite3_syscall_ptr(*xGetSystemCall)(sqlite3_vfs*, const char *zName);
    const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);
    /*
    ** The methods above are in versions 1 through 3 of the sqlite_vfs object.
    ** New fields may be appended in figure versions.  The iVersion
    ** value will increment whenever this happens.
    */
};
```

## Pager

一个数据库文件对应一个Pager实例,因此Pager是数据库文件的描述.

```c
struct Pager
{
    /* io函数 */
    sqlite3_vfs *pVfs;          /* OS functions to use for IO */
    /* 是否处于排他模式 */
    u8 exclusiveMode;           /* Boolean. True if locking_mode==EXCLUSIVE */
    u8 journalMode;             /* One of the PAGER_JOURNALMODE_* values */
    u8 useJournal;              /* Use a rollback journal on this file */
    /* 无需同步日志,如果为true */
    u8 noSync;                  /* Do not sync the journal if true */
    u8 fullSync;                /* Do extra syncs of the journal for robustness */
    u8 ckptSyncFlags;           /* SYNC_NORMAL or SYNC_FULL for checkpoint */
    u8 walSyncFlags;            /* SYNC_NORMAL or SYNC_FULL for wal writes */
    u8 syncFlags;               /* SYNC_NORMAL or SYNC_FULL otherwise */
    u8 tempFile;                /* zFilename is a temporary file */
    u8 readOnly;                /* True for a read-only database */
    u8 memDb;                   /* True to inhibit all file I/O */
    /**************************************************************************
    ** The following block contains those class members that change during
    ** routine opertion.  Class members not in this block are either fixed
    ** when the pager is first created or else only change when there is a
    ** significant mode change (such as changing the page_size, locking_mode,
    ** or the journal_mode).  From another view, these class members describe
    ** the "state" of the pager, while other class members describe the
    ** "configuration" of the pager.
    */
    u8 eState;                  /* Pager state (OPEN, READER, WRITER_LOCKED..) */
    /* 数据库文件当前持有的锁 */
    u8 eLock;                   /* Current lock held on database file */
    u8 changeCountDone;         /* Set after incrementing the change-counter */
    u8 setMaster;               /* True if a m-j name has been written to jrnl */
    u8 doNotSpill;              /* Do not spill the cache when non-zero */
    u8 doNotSyncSpill;          /* Do not do a spill that requires jrnl sync */
    /* 是否使用内存sub-journals */
    u8 subjInMemory;            /* True to use in-memory sub-journals */
    /* 数据库大小(用page计算) */
    Pgno dbSize;                /* Number of pages in the database */
    /* 数据库原本大小(page计算) */
    Pgno dbOrigSize;            /* dbSize before the current transaction */
    /* 数据库文件大小(page计算) */
    Pgno dbFileSize;            /* Number of pages in the database file */
    Pgno dbHintSize;            /* Value passed to FCNTL_SIZE_HINT call */
    int errCode;                /* One of several kinds of errors */
    /* 写入的记录个数 */
    int nRec;                   /* Pages journalled since last j-header written */
    u32 cksumInit;              /* Quasi-random value added to every checksum */
    u32 nSubRec;                /* Number of records written to sub-journal */
    Bitvec *pInJournal;         /* One bit for each page in the database file */
    /* 数据库的文件描述符 */
    sqlite3_file *fd;           /* File descriptor for database */
    /* 主日志的文件描述符 */
    sqlite3_file *jfd;          /* File descriptor for main journal */
    /* sub-journal */
    sqlite3_file *sjfd;         /* File descriptor for sub-journal */
    /* 当前日志文件的写偏移 */
    i64 journalOff;             /* Current write offset in the journal file */
    /* 记录日志文件头部偏移 */
    i64 journalHdr;             /* Byte offset to previous journal header */
    sqlite3_backup *pBackup;    /* Pointer to list of ongoing backup processes */
    PagerSavepoint *aSavepoint; /* Array of active savepoints */
    /* savepoint的个数 */
    int nSavepoint;             /* Number of elements in aSavepoint[] */
    char dbFileVers[16];        /* Changes whenever database file changes */
    /*
    ** End of the routinely-changing class members
    ***************************************************************************/

    u16 nExtra;                 /* Add this many bytes to each in-memory page */
    i16 nReserve;               /* Number of unused bytes at end of each page */
    u32 vfsFlags;               /* Flags for sqlite3_vfs.xOpen() */
    /* 扇区大小 */
    u32 sectorSize;             /* Assumed sector size during rollback */
    /* 页大小 */
    int pageSize;               /* Number of bytes in a page */

    Pgno mxPgno;                /* Maximum allowed size of the database */
    /* 日志文件大小限制 */
    i64 journalSizeLimit;       /* Size limit for persistent journal files */
    /* 数据库文件名称 */
    char *zFilename;            /* Name of the database file */
    /* 日志文件名称 */
    char *zJournal;             /* Name of the journal file */
    /* 当不能持有锁的时候,执行的函数 */
    int (*xBusyHandler)(void*); /* Function to call when busy */
    void *pBusyHandlerArg;      /* Context argument for xBusyHandler */
    int aStat[3];               /* Total cache hits, misses and writes */
    void (*xReiniter)(DbPage*); /* Call this routine when reloading pages */
#ifdef SQLITE_HAS_CODEC
    void *(*xCodec)(void*, void*, Pgno, int); /* Routine for en/decoding data */
    void (*xCodecSizeChng)(void*, int, int); /* Notify of page size changes */
    void (*xCodecFree)(void*);             /* Destructor for the codec */
    void *pCodec;               /* First argument to xCodec... methods */
#endif
    char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */
    PCache *pPCache;            /* Pointer to page cache object */
#ifndef SQLITE_OMIT_WAL
    Wal *pWal;                  /* Write-ahead log used by "journal_mode=wal" */
    char *zWal;                 /* File name for write-ahead log */
#endif
};
```

**eState**

SQLite最终都是通过连接的B-tree和pager从数据库读/写数据，通过B-tree的游标遍历存储在页面中的记录。游标在访问页面之前要把数据从磁盘加载到内存，而这就是页面的任务。任何时候，如果B-tree需要页面，它都会请求页面从磁盘中读取数据，然后把页面(page)加载到页面缓冲区，之后B-tree和与之关联的游标就可以访问位于页面中的记录了。Pager.eState可变的存储页面的当前‘state’。一个页面可能下列七个状态中的一个（打开(OPEN)，读取(READER)，写锁(WRITE_LOCKED)，错误(ERROR)，写缓存模式(WRITER_CACHEMOD)，写数据库模式(WRITER_DBMOD)，写结束(WRITER_FINISHED)）。

事务状态的列表展示如下：     

```c
                            OPEN <------+------+
                              |         |      |
                              V         |      |
               +---------> READER-------+      |
               |              |                |
               |              V                |
               |<-------WRITER_LOCKED------> ERROR
               |              |                ^
               |              V                |
               |<------WRITER_CACHEMOD-------->|
               |              |                |
               |              V                |
               |<-------WRITER_DBMOD---------->|
               |              |                |
               |              V                |
               +<------WRITER_FINISHED-------->+
```

状态转换如下,[]中的是对应的转换函数,通过对应的函数实现状态转换:

```c
   OPEN              -> READER              [sqlite3PagerSharedLock]
   READER            -> OPEN                [pager_unlock]

   READER            -> WRITER_LOCKED       [sqlite3PagerBegin]
   WRITER_LOCKED     -> WRITER_CACHEMOD     [pager_open_journal]
   WRITER_CACHEMOD   -> WRITER_DBMOD        [syncJournal]
   WRITER_DBMOD      -> WRITER_FINISHED     [sqlite3PagerCommitPhaseOne]
   WRITER_***        -> READER              [pager_end_transaction]

   WRITER_***        -> ERROR               [pager_error]
   ERROR             -> OPEN                [pager_unlock]
```


如果游标改变了页面，为了防止事务回滚，页面必须采取特殊的方式保存原来的page。总的来说，pager负责读写数据库，管理内存缓存和页面（page），以及管理事务，锁和崩溃恢复。

## PgHdr

PgHdr是对磁盘页的抽象.

```c
typedef struct PgHdr PgHdr;
/*
** Every page in the cache is controlled by an instance of the following
** structure.
*/
struct PgHdr /* 对页(page)的抽象 */
{
    sqlite3_pcache_page *pPage;    /* Pcache object page handle */
    void *pData;                   /* Page data */
    void *pExtra;                  /* Extra content */
    /* 脏页 */
    PgHdr *pDirty;                 /* Transient list of dirty pages */
    Pager *pPager;                 /* The pager this page is part of */
    /* 页号 */
    Pgno pgno;                     /* Page number for this page */
    u16 flags;                     /* PGHDR flags defined below */

    /**********************************************************************
    ** Elements above are public.  All that follows is private to pcache.c
    ** and should not be accessed by other modules.
    */
    i16 nRef;                      /* Number of users of this page */
    /* 指向包含了此page的cache对象 */
    PCache *pCache;                /* Cache that owns this page */

    PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
    PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
};

typedef struct PgHdr DbPage;
```

## sqlite3_pcache_page

pager模块cache所缓存的page数据.

```c
/*
** CAPI3REF: Custom Page Cache Object
**
** The sqlite3_pcache_page object represents a single page in the
** page cache.  The page cache will allocate instances of this
** object.  Various methods of the page cache use pointers to instances
** of this object as parameters or as their return value.
**
** See [sqlite3_pcache_methods2] for additional information.
*/
typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page
{
    void *pBuf;        /* The content of the page */
    void *pExtra;      /* Extra information associated with the page */
};
```

## Pcache

众所周知,磁盘的读写速度是远远要低于内存的,为了解决这个问题,sqlite3引入了cache.

```c
/*
** A complete page cache is an instance of this structure.
*/
struct PCache
{
    /* pDirty,pDirtyTail指向同一个链表的首尾 */
    PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */
    /* pSynced也指向dirty链表中的项--最后一个已经同步至磁盘的page */
    PgHdr *pSynced;                     /* Last synced page in dirty page list */
    int nRef;                           /* Number of referenced pages */
    int szCache;                        /* Configured cache size */
    int szPage;                         /* Size of every page in this cache */
    int szExtra;                        /* Size of extra space for each page */
    int bPurgeable;                     /* True if pages are on backing store */
    int (*xStress)(void*, PgHdr*);      /* Call to try make a page clean */
    void *pStress;                      /* Argument to xStress */
    sqlite3_pcache *pCache;             /* Pluggable cache module */
    PgHdr *pPage1;                      /* Reference to page 1 */
};
```

## PagerSavepoint

```c
/*
** An instance of the following structure is allocated for each active
** savepoint and statement transaction in the system. All such structures
** are stored in the Pager.aSavepoint[] array, which is allocated and
** resized using sqlite3Realloc().
**
** When a savepoint is created, the PagerSavepoint.iHdrOffset field is
** set to 0. If a journal-header is written into the main journal while
** the savepoint is active, then iHdrOffset is set to the byte offset
** immediately following the last journal record written into the main
** journal before the journal-header. This is required during savepoint
** rollback (see pagerPlaybackSavepoint()).
*/
typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint /* 保存点 */
{
    /* 主日志中的偏移量 */
    i64 iOffset;                 /* Starting offset in main journal */
    i64 iHdrOffset;              /* See above */
    /* 位图数据,用于记录哪些页位于保存点之中 */
    Bitvec *pInSavepoint;        /* Set of pages in this savepoint */
    /* 在建立保存点之前,数据库文件的大小(以page为单位) */
    Pgno nOrig;                  /* Original number of pages in file */
    Pgno iSubRec;                /* Index of first record in sub-journal */
#ifndef SQLITE_OMIT_WAL
    u32 aWalData[WAL_SAVEPOINT_NDATA];        /* WAL savepoint context */
#endif
};
```



# 操作函数

## sqlite3PagerOpen

sqlite3PagerOpen用于打开一个磁盘文件.

```c
/* Create a new pager cache. 创建一个新的pager cache.
** Under memory stress, invoke xStress to try to make pages clean.
** 如果内存紧张,调用xStress尝试回收内存,只有clean以及unpinned的页才可以被回收.
** Only clean and unpinned pages can be reclaimed.
*/
int sqlite3PagerOpen(
    sqlite3_vfs *pVfs,       /* The virtual file system to use */
    Pager **ppPager,         /* OUT: Return the Pager structure here */
    const char *zFilename,   /* 要打开的数据库文件名称 */
    int nExtra,              /* Extra bytes append to each in-memory page */
    int flags,               /* 控制此文件的标志 */
    int vfsFlags,            /* 传递给sqlite3_vfs.xOpen()的标志(flags) */
    void (*xReinit)(DbPage*) /* Function to reinitialize pages */
)
{
    u8 *pPtr;
    Pager *pPager = 0;       /* Pager object to allocate and return */
    int rc = SQLITE_OK;      /* Return code */
    int tempFile = 0;        /* True for temp files (incl. in-memory files) */
    int memDb = 0;           /* True if this is an in-memory file */
    int readOnly = 0;        /* True if this is a read-only file */
    int journalFileSize;     /* Bytes to allocate for each journal fd */
    char *zPathname = 0;     /* Full path to database file */
    int nPathname = 0;       /* Number of bytes in zPathname */
    int useJournal = (flags & PAGER_OMIT_JOURNAL) == 0; /* False to omit journal */
    int pcacheSize = sqlite3PcacheSize();       /* Bytes to allocate for PCache */
    /* 默认页大小 */
    u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */
    const char *zUri = 0;    /* URI args to copy */
    int nUri = 0;            /* Number of bytes of URI args at *zUri */

    /* Figure out how much space is required for each journal file-handle
    ** (there are two of them, the main journal and the sub-journal). This
    ** is the maximum space required for an in-memory journal file handle
    ** and a regular journal file-handle. Note that a "regular journal-handle"
    ** may be a wrapper capable of caching the first portion of the journal
    ** file in memory to implement the atomic-write optimization (see
    ** source file journal.c).
    */
    if (sqlite3JournalSize(pVfs) > sqlite3MemJournalSize())
    {
        journalFileSize = ROUND8(sqlite3JournalSize(pVfs));
    }
    else
    {
        journalFileSize = ROUND8(sqlite3MemJournalSize());
    }

    /* Set the output variable to NULL in case an error occurs. */
    *ppPager = 0;

    /* Compute and store the full pathname in an allocated buffer pointed
    ** to by zPathname, length nPathname. Or, if this is a temporary file,
    ** leave both nPathname and zPathname set to 0.
    */
    if (zFilename && zFilename[0])
    {
        const char *z;
        nPathname = pVfs->mxPathname + 1;
        zPathname = sqlite3DbMallocRaw(0, nPathname * 2);
        if (zPathname == 0)
        {
            return SQLITE_NOMEM;
        }
        zPathname[0] = 0; /* Make sure initialized even if FullPathname() fails */
        rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
        nPathname = sqlite3Strlen30(zPathname);
        z = zUri = &zFilename[sqlite3Strlen30(zFilename) + 1];
        while (*z)
        {
            z += sqlite3Strlen30(z) + 1;
            z += sqlite3Strlen30(z) + 1;
        }
        nUri = (int)(&z[1] - zUri);
        assert(nUri >= 0);
        if (rc == SQLITE_OK && nPathname + 8 > pVfs->mxPathname)
        {
            /* This branch is taken when the journal path required by
            ** the database being opened will be more than pVfs->mxPathname
            ** bytes in length. This means the database cannot be opened,
            ** as it will not be possible to open the journal file or even
            ** check for a hot-journal before reading.
            */
            rc = SQLITE_CANTOPEN_BKPT;
        }
        if (rc != SQLITE_OK)
        {
            sqlite3DbFree(0, zPathname);
            return rc;
        }
    }

    /* Allocate memory for the Pager structure, PCache object, the
    ** three file descriptors, the database file name and the journal
    ** file name. The layout in memory is as follows:
    **
    **     Pager object                    (sizeof(Pager) bytes)
    **     PCache object                   (sqlite3PcacheSize() bytes)
    **     Database file handle            (pVfs->szOsFile bytes)
    **     Sub-journal file handle         (journalFileSize bytes)
    **     Main journal file handle        (journalFileSize bytes)
    **     Database file name              (nPathname+1 bytes)
    **     Journal file name               (nPathname+8+1 bytes)
    */
    pPtr = (u8 *)sqlite3MallocZero(
               ROUND8(sizeof(*pPager)) +      /* Pager structure */
               ROUND8(pcacheSize) +           /* PCache object */
               ROUND8(pVfs->szOsFile) +       /* The main db file */
               journalFileSize * 2 +          /* The two journal files */
               nPathname + 1 + nUri +         /* zFilename */
               nPathname + 8 + 2              /* zJournal */
#ifndef SQLITE_OMIT_WAL
               + nPathname + 4 + 2            /* zWal */
#endif
           ); /* 为了避免碎片,将内存分配到一起了 */

    if (!pPtr)
    {
        sqlite3DbFree(0, zPathname);
        return SQLITE_NOMEM;
    }
    pPager = (Pager*)(pPtr);
    pPager->pPCache = (PCache*)(pPtr += ROUND8(sizeof(*pPager)));
    pPager->fd = (sqlite3_file*)(pPtr += ROUND8(pcacheSize));
    pPager->sjfd = (sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));
    pPager->jfd = (sqlite3_file*)(pPtr += journalFileSize);
    pPager->zFilename = (char*)(pPtr += journalFileSize);

    /* 填充Pager.zFilename以及Pager.zJournal buffers,如果需要的话 */
    if (zPathname)
    {
        assert(nPathname > 0);
        pPager->zJournal = (char*)(pPtr += nPathname + 1 + nUri);
        memcpy(pPager->zFilename, zPathname, nPathname);
        if (nUri) memcpy(&pPager->zFilename[nPathname + 1], zUri, nUri);
        memcpy(pPager->zJournal, zPathname, nPathname);
        memcpy(&pPager->zJournal[nPathname], "-journal\000", 8 + 1);
        sqlite3FileSuffix3(pPager->zFilename, pPager->zJournal);
#ifndef SQLITE_OMIT_WAL
        pPager->zWal = &pPager->zJournal[nPathname + 8 + 1];
        memcpy(pPager->zWal, zPathname, nPathname);
        memcpy(&pPager->zWal[nPathname], "-wal\000", 4 + 1);
        sqlite3FileSuffix3(pPager->zFilename, pPager->zWal);
#endif
        sqlite3DbFree(0, zPathname);
    }
    pPager->pVfs = pVfs;
    pPager->vfsFlags = vfsFlags;

    /* Open the pager file. */
    if (zFilename && zFilename[0])
    {
        int fout = 0;    /* VFS flags returned by xOpen() */
        rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
        assert(!memDb);
        readOnly = (fout & SQLITE_OPEN_READONLY);

        /* If the file was successfully opened for read/write access,
        ** choose a default page size in case we have to create the
        ** database file. The default page size is the maximum of:
        **
        **    + SQLITE_DEFAULT_PAGE_SIZE,
        **    + The value returned by sqlite3OsSectorSize()
        **    + The largest page size that can be written atomically.
        */
        if (rc == SQLITE_OK && !readOnly)
        {
            setSectorSize(pPager);
            assert(SQLITE_DEFAULT_PAGE_SIZE <= SQLITE_MAX_DEFAULT_PAGE_SIZE);
            if (szPageDflt < pPager->sectorSize)
            {
                if (pPager->sectorSize > SQLITE_MAX_DEFAULT_PAGE_SIZE)
                {
                    szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;
                }
                else
                {
                    szPageDflt = (u32)pPager->sectorSize;
                }
            }
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
            {
                int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
                int ii;
                assert(SQLITE_IOCAP_ATOMIC512 == (512 >> 8));
                assert(SQLITE_IOCAP_ATOMIC64K == (65536 >> 8));
                assert(SQLITE_MAX_DEFAULT_PAGE_SIZE <= 65536);
                for (ii = szPageDflt; ii <= SQLITE_MAX_DEFAULT_PAGE_SIZE; ii = ii * 2)
                {
                    if (iDc & (SQLITE_IOCAP_ATOMIC | (ii >> 8)))
                    {
                        szPageDflt = ii;
                    }
                }
            }
#endif
        }
    }
    else
    {
        /* If a temporary file is requested, it is not opened immediately.
        ** In this case we accept the default page size and delay actually
        ** opening the file until the first call to OsWrite().
        **
        ** This branch is also run for an in-memory database. An in-memory
        ** database is the same as a temp-file that is never written out to
        ** disk and uses an in-memory rollback journal.
        */
        tempFile = 1;
        pPager->eState = PAGER_READER;
        pPager->eLock = EXCLUSIVE_LOCK;
        readOnly = (vfsFlags & SQLITE_OPEN_READONLY);
    }

    /* The following call to PagerSetPagesize() serves to set the value of
    ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.
    */
    if (rc == SQLITE_OK)
    {
        rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);
        testcase(rc != SQLITE_OK);
    }

    /* If an error occurred in either of the blocks above, free the
    ** Pager structure and close the file.
    */
    if (rc != SQLITE_OK)
    {
        assert(!pPager->pTmpSpace);
        sqlite3OsClose(pPager->fd);
        sqlite3_free(pPager);
        return rc;
    }

    /* Initialize the PCache object. */
    nExtra = ROUND8(nExtra);
    sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,
                      !memDb ? pagerStress : 0, (void *)pPager, pPager->pPCache);

    PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));
    IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename))

    pPager->useJournal = (u8)useJournal;
    pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;
    pPager->tempFile = (u8)tempFile;
    assert(tempFile == PAGER_LOCKINGMODE_NORMAL
           || tempFile == PAGER_LOCKINGMODE_EXCLUSIVE);
    assert(PAGER_LOCKINGMODE_EXCLUSIVE == 1);
    pPager->exclusiveMode = (u8)tempFile;
    pPager->changeCountDone = pPager->tempFile;
    pPager->memDb = (u8)memDb;
    pPager->readOnly = (u8)readOnly;
    assert(useJournal || pPager->tempFile);
    pPager->noSync = pPager->tempFile;
    if (pPager->noSync)
    {
        assert(pPager->fullSync == 0);
        assert(pPager->syncFlags == 0);
        assert(pPager->walSyncFlags == 0);
        assert(pPager->ckptSyncFlags == 0);
    }
    else
    {
        pPager->fullSync = 1;
        pPager->syncFlags = SQLITE_SYNC_NORMAL;
        pPager->walSyncFlags = SQLITE_SYNC_NORMAL | WAL_SYNC_TRANSACTIONS;
        pPager->ckptSyncFlags = SQLITE_SYNC_NORMAL;
    }
    pPager->nExtra = (u16)nExtra; /* 额外数据大小 */
    pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;
    assert(isOpen(pPager->fd) || tempFile);
    setSectorSize(pPager);
    if (!useJournal)
    {
        pPager->journalMode = PAGER_JOURNALMODE_OFF; /* 关闭日志 */
    }
    else if (memDb)
    {
        pPager->journalMode = PAGER_JOURNALMODE_MEMORY; /* 内存数据库 */
    }
    pPager->xReiniter = xReinit;
    *ppPager = pPager;
    return SQLITE_OK;
}
```

## sqlite3PagerWrite

sqlite3PagerWrite用于将数据库的一个page标记为可写.通知pager模块,将对应的page先写入到磁盘上去,方便以后的回滚/提交操作.

```c
/*
** Mark a data page as writeable. This routine must be called before
** making changes to a page. The caller must check the return value
** of this function and be careful not to change any page data unless
** this routine returns SQLITE_OK.
**
** The difference between this function and pager_write() is that this
** function also deals with the special case where 2 or more pages
** fit on a single disk sector. In this case all co-resident pages
** must have been written to the journal file before returning.
**
** If an error occurs, SQLITE_NOMEM or an IO error code is returned
** as appropriate. Otherwise, SQLITE_OK.
** 将数据库的页标记为可写
*/
int sqlite3PagerWrite(DbPage *pDbPage)
{
    int rc = SQLITE_OK;

    PgHdr *pPg = pDbPage;
    Pager *pPager = pPg->pPager;
    /* 计算每一个扇区可以包含多少page */
    Pgno nPagePerSector = (pPager->sectorSize / pPager->pageSize);

    if (nPagePerSector > 1) /* 1个扇区可以包含多个page,写入日志文件都是以扇区为单位,所以这里要写入多个page */
    {
        /* 数据库文件总页数 */
        Pgno nPageCount;          /* Total number of pages in database file */
        /* pPg所在扇区的第一个page的页号 */
        Pgno pg1;                 /* First page of the sector pPg is located on. */
        /* 要写入的page的个数 */
        int nPage = 0;            /* Number of pages starting at pg1 to journal */
        int ii;                   /* Loop counter */
        int needSync = 0;         /* True if any page has PGHDR_NEED_SYNC */

        /* Set the doNotSyncSpill flag to 1. This is because we cannot allow
        ** a journal header to be written between the pages journaled by
        ** this function.
        */
        pPager->doNotSyncSpill++;

        /* This trick assumes that both the page-size and sector-size are
        ** an integer power of 2. It sets variable pg1 to the identifier
        ** of the first page of the sector pPg is located on.
        ** 我们假定page大小和sector大小都是2的幂次,
        ** pg1设置为pPg所在扇区的第一个page的页号
        */
        pg1 = ((pPg->pgno - 1) & ~(nPagePerSector - 1)) + 1;

        nPageCount = pPager->dbSize; /* 数据库大小(单位为页) */
        if (pPg->pgno > nPageCount) /* 新页 */
        {
            nPage = (pPg->pgno - pg1) + 1; /* 从pg1写到pPg->pgno即可 */
        }
        else if ((pg1 + nPagePerSector - 1) > nPageCount) /* 从pg1开始,剩余量不足一个sector */
        {
            /* 写到数据库末尾所在的页即可 */
            nPage = nPageCount + 1 - pg1;
        }
        else
        {
            nPage = nPagePerSector; /* 否则写满完整的一个sector */
        }

        for (ii = 0; ii < nPage && rc == SQLITE_OK; ii++)
        {
            Pgno pg = pg1 + ii;
            PgHdr *pPage;
            /* 如果page并不位于日志文件之中 */
            if (pg == pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg))
            {
                if (pg != PAGER_MJ_PGNO(pPager))
                {
                    rc = sqlite3PagerGet(pPager, pg, &pPage); /* 获取一个磁盘page的缓存 */
                    if (rc == SQLITE_OK)
                    {
                        /* 写入日志文件 */
                        rc = pager_write(pPage);
                        if (pPage->flags & PGHDR_NEED_SYNC)
                        {
                            needSync = 1; /* 同步表示需要立即写入磁盘 */
                        }
                        sqlite3PagerUnref(pPage);
                    }
                }
            }
            else if ((pPage = pager_lookup(pPager, pg)) != 0)
            {
                if (pPage->flags & PGHDR_NEED_SYNC)
                {
                    needSync = 1;
                }
                sqlite3PagerUnref(pPage);
            }
        }

        /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages
        ** starting at pg1, then it needs to be set for all of them. Because
        ** writing to any of these nPage pages may damage the others, the
        ** journal file must contain sync()ed copies of all of them
        ** before any of them can be written out to the database file.
        */
        if (rc == SQLITE_OK && needSync)
        {
            assert(!MEMDB);
            for (ii = 0; ii < nPage; ii++)
            {
                PgHdr *pPage = pager_lookup(pPager, pg1 + ii);
                if (pPage)
                {
                    pPage->flags |= PGHDR_NEED_SYNC;
                    sqlite3PagerUnref(pPage);
                }
            }
        }
        pPager->doNotSyncSpill--;
    }
    else /* 1个扇区只能包含1页或者包含不了一页 */
    {
        rc = pager_write(pDbPage);
    }
    return rc;
}
```

### pager_write

pager_write将内存中的page标记为可写.

```c
/*
** Mark a single data page as writeable. The page is written into the
** main journal or sub-journal as required. If the page is written into
** one of the journals, the corresponding bit is set in the
** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs
** of any open savepoints as appropriate.
** 将一个单独的数据页(page)标记为可写
*/
static int pager_write(PgHdr *pPg)
{
    void *pData = pPg->pData;
    Pager *pPager = pPg->pPager;
    int rc = SQLITE_OK;

    /* If an error has been previously detected, report the same error
    ** again. This should not happen, but the check provides robustness. */
    if (NEVER(pPager->errCode))  return pPager->errCode;

    /* Higher-level routines never call this function if database is not
    ** writable.  But check anyway, just for robustness. */
    if (NEVER(pPager->readOnly)) return SQLITE_PERM;

    CHECK_PAGE(pPg);

    /* The journal file needs to be opened. Higher level routines have already
    ** obtained the necessary locks to begin the write-transaction, but the
    ** rollback journal might not yet be open. Open it now if this is the case.
    **
    ** This is done before calling sqlite3PcacheMakeDirty() on the page.
    ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then
    ** an error might occur and the pager would end up in WRITER_LOCKED state
    ** with pages marked as dirty in the cache.
    */
    if (pPager->eState == PAGER_WRITER_LOCKED)
    {
        rc = pager_open_journal(pPager); /* 打开日志文件 */
        if (rc != SQLITE_OK) return rc;
    }

    /* 将page标记为dirty,如果page早已经写入日志,那么函数可以立刻返回 */
    sqlite3PcacheMakeDirty(pPg);
    if (pageInJournal(pPg) && !subjRequiresPage(pPg))
    {
        assert(!pagerUseWal(pPager));
    }
    else
    {
        /* The transaction journal now exists and we have a RESERVED or an
        ** EXCLUSIVE lock on the main database file.  Write the current page to
        ** the transaction journal if it is not there already.
        ** 事务日志现在存在,而且当前我们在主数据库文件上拥有一个RESERVED/EXCLUSIVE锁,如果事务日志
        ** 不存在的话,将当前的页写入.
        */
        if (!pageInJournal(pPg) && !pagerUseWal(pPager))
        {
            /* pPg->pgno <= pPager->dbOrigSize表示只是修改 */
            if (pPg->pgno <= pPager->dbOrigSize && isOpen(pPager->jfd))
            {
                u32 cksum;
                char *pData2;
                i64 iOff = pPager->journalOff;

                CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2);
                cksum = pager_cksum(pPager, (u8*)pData2);

                /* Even if an IO or diskfull error occurs while journalling the
                ** page in the block above, set the need-sync flag for the page.
                ** Otherwise, when the transaction is rolled back, the logic in
                ** playback_one_page() will think that the page needs to be restored
                ** in the database file. And if an IO error occurs while doing so,
                ** then corruption may follow.
                */
                pPg->flags |= PGHDR_NEED_SYNC;
                /* 日志中写入页号 */
                rc = write32bits(pPager->jfd, iOff, pPg->pgno);
                if (rc != SQLITE_OK) return rc;
                /* 写入内容 */
                rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff + 4);
                if (rc != SQLITE_OK) return rc;
                /* 写入checksum */
                rc = write32bits(pPager->jfd, iOff + pPager->pageSize + 4, cksum);
                if (rc != SQLITE_OK) return rc;

                IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno,
                         pPager->journalOff, pPager->pageSize));
                PAGER_INCR(sqlite3_pager_writej_count);
                PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",
                            PAGERID(pPager), pPg->pgno,
                            ((pPg->flags & PGHDR_NEED_SYNC) ? 1 : 0), pager_pagehash(pPg)));
                /* 记录偏移 */
                pPager->journalOff += 8 + pPager->pageSize;
                /* 记录数目+1 */
                pPager->nRec++;
                assert(pPager->pInJournal != 0);
                /* 标记bitmap,表示页已经存在于日志中 */
                rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
                testcase(rc == SQLITE_NOMEM);
                assert(rc == SQLITE_OK || rc == SQLITE_NOMEM);
                rc |= addToSavepointBitvecs(pPager, pPg->pgno);
                if (rc != SQLITE_OK)
                {
                    return rc;
                }
            }
            else
            {
                if (pPager->eState != PAGER_WRITER_DBMOD)
                {
                    pPg->flags |= PGHDR_NEED_SYNC;
                }
            }
        }

        /* If the statement journal is open and the page is not in it,
        ** then write the current page to the statement journal.  Note that
        ** the statement journal format differs from the standard journal format
        ** in that it omits the checksums and the header.
        */
        if (subjRequiresPage(pPg))
        {
            rc = subjournalPage(pPg);
        }
    }

    /* 更新数据库的大小,这一点很重要 */
    if (pPager->dbSize < pPg->pgno)
    {
        pPager->dbSize = pPg->pgno;
    }
    return rc;
}
```

#### sqlite3PcacheMakeDirty

```c
/*
** Add page pPage to the head of the dirty list (PCache1.pDirty is set to
** pPage).
** 将page加入dirty链表
*/
static void pcacheAddToDirtyList(PgHdr *pPage)
{
    PCache *p = pPage->pCache;

    assert(pPage->pDirtyNext == 0 && pPage->pDirtyPrev == 0 && p->pDirty != pPage);

    pPage->pDirtyNext = p->pDirty;
    if (pPage->pDirtyNext)
    {
        assert(pPage->pDirtyNext->pDirtyPrev == 0);
        pPage->pDirtyNext->pDirtyPrev = pPage;
    }
    p->pDirty = pPage;
    if (!p->pDirtyTail)
    {
        p->pDirtyTail = pPage;
    }
    if (!p->pSynced && 0 == (pPage->flags & PGHDR_NEED_SYNC))
    {
        p->pSynced = pPage;
    }
}

/*
** Make sure the page is marked as dirty. If it isn't dirty already,
** make it so.
** 将指定的page标记为dirty
*/
void sqlite3PcacheMakeDirty(PgHdr *p)
{
    p->flags &= ~PGHDR_DONT_WRITE;
    assert(p->nRef > 0);
    if (0 == (p->flags & PGHDR_DIRTY))
    {
        p->flags |= PGHDR_DIRTY;
        pcacheAddToDirtyList(p);
    }
}
```

#### pageInJournal

```c
/*
** Return true if the page is already in the journal file.
** 如果page已经存在于日志(journal)文件中,返回true
*/
static int pageInJournal(PgHdr *pPg)
{
    return sqlite3BitvecTest(pPg->pPager->pInJournal, pPg->pgno);
}
```

#### pagerUseWal

```c
static int pagerUseWal(Pager *pPager)
{
    return (pPager->pWal != 0);
}
```



## sqlite3PagerAcquire

sqlite3PageAcquire用于获取一个DbPage.

```c
int sqlite3PagerAcquire(
    Pager *pPager,      /* The pager open on the database file */
    Pgno pgno,          /* 要获取的page的页号 */
    DbPage **ppPage,    /* Write a pointer to the page here */
    int noContent       /* Do not bother reading content from disk if true */
)
{
    int rc;
    PgHdr *pPg;

    if (pgno == 0)
    {
        return SQLITE_CORRUPT_BKPT;
    }

    /* If the pager is in the error state, return an error immediately.
    ** Otherwise, request the page from the PCache layer. */
    if (pPager->errCode != SQLITE_OK)
    {
        rc = pPager->errCode;
    }
    else
    {
        rc = sqlite3PcacheFetch(pPager->pPCache, pgno, 1, ppPage);
    }

    if (rc != SQLITE_OK)
    {
        /* Either the call to sqlite3PcacheFetch() returned an error or the
        ** pager was already in the error-state when this function was called.
        ** Set pPg to 0 and jump to the exception handler.  */
        pPg = 0;
        goto pager_acquire_err;
    }

    if ((*ppPage)->pPager && !noContent)
    {
        /* In this case the pcache already contains an initialized copy of
        ** the page. Return without further ado.  */
        assert(pgno <= PAGER_MAX_PGNO && pgno != PAGER_MJ_PGNO(pPager));
        pPager->aStat[PAGER_STAT_HIT]++;
        return SQLITE_OK;

    }
    else
    {
        /* The pager cache has created a new page. Its content needs to
        ** be initialized.  */
        pPg = *ppPage;
        pPg->pPager = pPager;

        /* The maximum page number is 2^31. Return SQLITE_CORRUPT if a page
        ** number greater than this, or the unused locking-page, is requested. */
        if (pgno > PAGER_MAX_PGNO || pgno == PAGER_MJ_PGNO(pPager))
        {
            rc = SQLITE_CORRUPT_BKPT;
            goto pager_acquire_err;
        }

        if (MEMDB || pPager->dbSize < pgno || noContent || !isOpen(pPager->fd))
        {
            if (pgno > pPager->mxPgno)
            {
                rc = SQLITE_FULL;
                goto pager_acquire_err;
            }
            if (noContent)
            {
                /* Failure to set the bits in the InJournal bit-vectors is benign.
                ** It merely means that we might do some extra work to journal a
                ** page that does not need to be journaled.  Nevertheless, be sure
                ** to test the case where a malloc error occurs while trying to set
                ** a bit in a bit vector.
                */
                sqlite3BeginBenignMalloc();
                if (pgno <= pPager->dbOrigSize)
                {
                    TESTONLY(rc =) sqlite3BitvecSet(pPager->pInJournal, pgno);
                    testcase(rc == SQLITE_NOMEM);
                }
                TESTONLY(rc =) addToSavepointBitvecs(pPager, pgno);
                testcase(rc == SQLITE_NOMEM);
                sqlite3EndBenignMalloc();
            }
            memset(pPg->pData, 0, pPager->pageSize);
            IOTRACE(("ZERO %p %d\n", pPager, pgno));
        }
        else
        {
            assert(pPg->pPager == pPager);
            pPager->aStat[PAGER_STAT_MISS]++;
            rc = readDbPage(pPg);
            if (rc != SQLITE_OK)
            {
                goto pager_acquire_err;
            }
        }
        pager_set_pagehash(pPg);
    }

    return SQLITE_OK;

pager_acquire_err:
    if (pPg)
    {
        sqlite3PcacheDrop(pPg);
    }
    pagerUnlockIfUnused(pPager);
    *ppPage = 0;
    return rc;
}
```

## sqlite3PcacheFetch

sqlite3PcacheFetch用于从pager实例的cache之中获取一个页.

```c
/*
** Try to obtain a page from the cache.
** 根据页号(pgno),从cache中获取一个页(page)
*/
int sqlite3PcacheFetch(
    PCache *pCache,       /* Obtain the page from this cache */
    Pgno pgno,            /* Page number to obtain */
    int createFlag,       /* If true, create page if it does not exist already */
    PgHdr **ppPage        /* Write the page here */
)
{
    sqlite3_pcache_page *pPage = 0;
    PgHdr *pPgHdr = 0;
    int eCreate;

    assert(pCache != 0);
    assert(createFlag == 1 || createFlag == 0);
    assert(pgno > 0);

    /* If the pluggable cache (sqlite3_pcache*) has not been allocated,
    ** allocate it now.
    */
    if (!pCache->pCache && createFlag)
    {
        sqlite3_pcache *p;
        /* 创建一个cache */
        p = sqlite3GlobalConfig.pcache2.xCreate(
                pCache->szPage, pCache->szExtra + sizeof(PgHdr), pCache->bPurgeable
            );
        if (!p)
        {
            return SQLITE_NOMEM;
        }
        sqlite3GlobalConfig.pcache2.xCachesize(p, numberOfCachePages(pCache));
        pCache->pCache = p;
    }
    /* 是否需要创建 */
    eCreate = createFlag * (1 + (!pCache->bPurgeable || !pCache->pDirty));
    if (pCache->pCache)
    {
        pPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, eCreate);
    }

    if (!pPage && eCreate == 1) /* 如果找不到可用的pcache_page,那么尝试回收 */
    {
        PgHdr *pPg;
        /* Find a dirty page to write-out and recycle. First try to find a
        ** page that does not require a journal-sync (one with PGHDR_NEED_SYNC
        ** cleared), but if that is not possible settle for any other
        ** unreferenced dirty page.
        */
        expensive_assert(pcacheCheckSynced(pCache));
        for (pPg = pCache->pSynced;
             pPg && (pPg->nRef || (pPg->flags & PGHDR_NEED_SYNC));
             pPg = pPg->pDirtyPrev
            );
        pCache->pSynced = pPg;
        if (!pPg)
        {
            for (pPg = pCache->pDirtyTail; pPg && pPg->nRef; pPg = pPg->pDirtyPrev);
        }
        if (pPg)
        {
            int rc;
            rc = pCache->xStress(pCache->pStress, pPg); /* 尝试回收一个pcache_page */
            if (rc != SQLITE_OK && rc != SQLITE_BUSY)
            {
                return rc;
            }
        }

        pPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, 2); /* 再次尝试从pache中获取 */
    }

    if (pPage)
    {
        pPgHdr = (PgHdr *)pPage->pExtra;
        if (!pPgHdr->pPage)
        {
            memset(pPgHdr, 0, sizeof(PgHdr));
            pPgHdr->pPage = pPage;
            pPgHdr->pData = pPage->pBuf;
            pPgHdr->pExtra = (void *)&pPgHdr[1];
            memset(pPgHdr->pExtra, 0, pCache->szExtra);
            pPgHdr->pCache = pCache;
            pPgHdr->pgno = pgno;
        }

        if (0 == pPgHdr->nRef)
        {
            pCache->nRef++;
        }
        pPgHdr->nRef++;
        if (pgno == 1)
        {
            pCache->pPage1 = pPgHdr;
        }
    }
    *ppPage = pPgHdr; /* 记录结果 */
    return (pPgHdr == 0 && eCreate) ? SQLITE_NOMEM : SQLITE_OK;
}

```

## sqlite3PcacheTruncate

sqlite3PcacheTruncate用于回收对应的page.

```c
/*
** Drop every cache entry whose page number is greater than "pgno". The
** caller must ensure that there are no outstanding references to any pages
** other than page 1 with a page number greater than pgno.
**
** If there is a reference to page 1 and the pgno parameter passed to this
** function is 0, then the data area associated with page 1 is zeroed, but
** the page object is not dropped.
*/
void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno)
{
    if (pCache->pCache)
    {
        PgHdr *p;
        PgHdr *pNext;
        for (p = pCache->pDirty; p; p = pNext)
        {
            pNext = p->pDirtyNext;
            /* This routine never gets call with a positive pgno except right
            ** after sqlite3PcacheCleanAll().  So if there are dirty pages,
            ** it must be that pgno==0.
            */
            assert(p->pgno > 0);
            if (ALWAYS(p->pgno > pgno))
            {
                assert(p->flags & PGHDR_DIRTY);
                sqlite3PcacheMakeClean(p);
            }
        }
        if (pgno == 0 && pCache->pPage1)
        {
            memset(pCache->pPage1->pData, 0, pCache->szPage);
            pgno = 1;
        }
        sqlite3GlobalConfig.pcache2.xTruncate(pCache->pCache, pgno + 1);
    }
}
```

#### sqlite3PcacheMakeClean

```c
/*
** Wrapper around the pluggable caches xUnpin method. If the cache is
** being used for an in-memory database, this function is a no-op.
*/
static void pcacheUnpin(PgHdr *p)
{
    PCache *pCache = p->pCache;
    if (pCache->bPurgeable) /* 可回收 */
    {
        if (p->pgno == 1)
        {
            pCache->pPage1 = 0;
        }
        sqlite3GlobalConfig.pcache2.xUnpin(pCache->pCache, p->pPage, 0);
    }
}

/*
** Make sure the page is marked as clean. If it isn't clean already,
** make it so.
*/
void sqlite3PcacheMakeClean(PgHdr *p)
{
    if ((p->flags & PGHDR_DIRTY))
    {
        pcacheRemoveFromDirtyList(p);
        p->flags &= ~(PGHDR_DIRTY | PGHDR_NEED_SYNC);
        if (p->nRef == 0)
        {
            pcacheUnpin(p);
        }
    }
}
```



## sqlite3PagerOpenSavepoint

创建一个新的保存点.

```c
/*
** Check that there are at least nSavepoint savepoints open. If there are
** currently less than nSavepoints open, then open one or more savepoints
** to make up the difference. If the number of savepoints is already
** equal to nSavepoint, then this function is a no-op.
** 创建一个新的保存点
**
** If a memory allocation fails, SQLITE_NOMEM is returned. If an error
** occurs while opening the sub-journal file, then an IO error code is
** returned. Otherwise, SQLITE_OK.
*/
int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint)
{
    int rc = SQLITE_OK;                       /* Return code */
    int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */

    assert(pPager->eState >= PAGER_WRITER_LOCKED); /* 保证已经加了写锁 */

    if (nSavepoint > nCurrent && pPager->useJournal)
    {
        int ii;                                 /* Iterator variable */
        PagerSavepoint *aNew;                   /* New Pager.aSavepoint array */

        /* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM
        ** if the allocation fails. Otherwise, zero the new portion in case a
        ** malloc failure occurs while populating it in the for(...) loop below.
        ** 重新分配
        */
        aNew = (PagerSavepoint *)sqlite3Realloc(
                   pPager->aSavepoint, sizeof(PagerSavepoint) * nSavepoint
               );
        if (!aNew)
        {
            return SQLITE_NOMEM;
        }
        memset(&aNew[nCurrent], 0, (nSavepoint - nCurrent) * sizeof(PagerSavepoint));
        pPager->aSavepoint = aNew;

        /* Populate the PagerSavepoint structures just allocated. */
        for (ii = nCurrent; ii < nSavepoint; ii++)
        {
            aNew[ii].nOrig = pPager->dbSize;
            if (isOpen(pPager->jfd) && pPager->journalOff > 0)
            {
                aNew[ii].iOffset = pPager->journalOff;
            }
            else
            {
                aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager); /* 开始的位置 */
            }
            aNew[ii].iSubRec = pPager->nSubRec;
            /* 保存点中页的个数 */
            aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
            if (!aNew[ii].pInSavepoint)
            {
                return SQLITE_NOMEM;
            }
            if (pagerUseWal(pPager))
            {
                sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
            }
            pPager->nSavepoint = ii + 1;
        }
        assert(pPager->nSavepoint == nSavepoint);
        assertTruncateConstraint(pPager);
    }

    return rc;
}
```

