# 第二章 数据库文件格式

在深入 SQLite 引擎之前,我先在接下来这两节中介绍一下数据库命名规范和数据库文件格式.

## 2.1 数据库命名规范

应用程序通过向sqlite3_open传入数据库文件名来打开数据库.文件名可以是相对路径也可以是绝对路径.SQLite支持常见的文件系统支持的文件名,但是有两条例外:

+ 如果文件名是c语言NULL指针(例如:0),SQLite打开一个新的临时文件

+ 如果文件名是":memory:",SQLite创建一个只在内存中存在的数据库(in-memory database)

在这两种情况下创建的数据库文件是临时的,只要数据库关闭,文件就会消失.

**NOTE**

SQLite为临时文件随机命名.文件名的前缀是sqlite_,后面紧跟着16个随机字母或数字.文件存储在本地系统默认的临时文件夹中.SQLite会依次尝试以下的存储路径:(1)/var/tmp, (2)/usr/tmp, (3)/tmp, (4)当前工作路径.

无论以哪种方式打开数据库(文件方式,临时文件方式,内存数据库方式),在SQLite内部,打开的数据库都被命名为main.

**NOTE**

在SQLite内部,数据库文件的名字不是数据库名.他们是两个不同的概念.通过使用attach命令,你可以将一个同样的数据库文件以一个不同的数据库名称连接到一个数据库连接上.你可以通过这些数据库名称对数据库文件进行操作.更多有关attach的信息请查询官网.

每当应用程序使用sqlite3_open打开一个数据库连接,SQLite就为这个数据库连接维护一个独立的临时数据库,这个临时数据库被命名为temp.temp数据库存储临时实体,例如:表和索引.(应用程序可以在SQL语句中使用main或者temp,例如:select * from temp.table1将返回temp数据库的table1的所有行,而不是从main数据库返回这些信息.Temp数据库的目录名是sqlite_temp_master)临时实体只对本数据库连接是可见的(而不是指向同一个文件的,同一个线程、进程或者其他进程中的数据库连接).SQLite将temp数据库存储在一个单独的临时文件中,而不是存储在main数据库文件中.当应用程序关闭数据库连接的时候,temp文件将被删除.

## 2.2 数据库文件结构

除了存储数据库(in-memory databases),SQLite 把所有的(主要或临时)数据库都存储在单个数据库文件中.

为了便于管理和读/写数据库,SQLite 把每一个数据库(包括存储数据库)都划分为一个叫做数据库页或简称为页的固定大小的区域.页的大小是在 512 至 32,768 之间(包括它们)的 2 的指数;默认的值是 1024.(The upper bound is a limit imposed by the necessity of storing page size in 2-byte signed integer variables in various places in code and external storage.)数据库是一个页里面的(可伸缩性)的数组.每个数组的索引是被叫做页码(page number).页码从 1 开始,可连续地增加到 2,147,483,647(2^31 - 1).(这个上界可能会根据本地文件系统最大文件大小做进一步限制.)0 这个页码是空页(NULL page)或者不是一页 —— 这个页在物理上是不存在的.第 1 页和后面的页,是按顺序依次存储在数据库文件中的.

**注意**

每当一个数据库文件被创建,SQLite使用默认页大小(在编译时指定的大小),在创建数据库的第1个表之前,可以使用预处理命令修改页的大小.

页的种类有4种:叶子页,内部页,溢出页,自由页.自由页是非激活页(还没有使用的页),其他的是激活页.B+树内部页包含搜索信息(B树内部页包含搜索信息和数据).B+树的叶子页存储实际的数据(例如:表中每行的数据).如果一页不能盛放一行数据,数据的一部分会存储在B+树的叶子页,另一部分存储在溢出页中.

SQLite可以使用任何类型的页,除了页1,页1永远是B+树的内部页,保存有100byte的文件头信息,存储偏移量是0.文件头信息决定了该数据库文件的结构.当数据库文件被创建时,SQLite初始化文件头信息.文件头的格式如下表所示,前两列的存储单位是byte.

![Table 2-1. Structure of database file header](pic/02.DatabaseFileFormat/Table2-1.StructureOfDatabaseFileHeader.png)

下面是每个头部的描述:

+ Header string

这是一个16byte的string:"SQLite format 3."

+ Page size

页的大小.

+ File format

偏移量为18、19的两个byte用来存储文件格式版本,在当前版本中,这两个值都是1,否则将返回一个error值.如果将来文件格式发生改变,这两个值会增长以表示新的文件格式版本.

+ Reserved space

处于一些原因,SQLite在每一页底部保留一小块固定空间(<=255bytes),空间的大小保存在reserveed space变量中,默认值是0.使用SQLite内建加密模式时,这个值会发生变化.

+ Embedded payload

最大碎片负载(偏移量是21)指的是每页能够用于存储B/B+树内部节点的空间.255表示100%.默认值是64(25%),这个值用来限定cell的最大值,即每个节点最少有4个cell.如果cell的大小超过允许的最大值,SQLite就创建溢出页,把尽量多的byte移动到溢出页中,但是不能在分割的过程中导致cell的大小小于最小embedded payload(偏移量是22,默认值是32,即12.5%).

叶子页最小负载(偏移量23)和最小embedded payload相似,但是是针对B+树的叶子页来说的.(默认值是32,12.5%).叶子页的最大负载百分比永远是100%,文件头中并没有保存该值的变量.

+ File change counter

文件更改次数(偏移量24)被用于事务管理.每个事务都会使这个值加1.这个值用来指示什么时候数据库被改变,辅助pager模块避免盲目刷新cache.截止到目前为止,这个功能还没有实现.Pager模块负责增加这个值.

+ Free list

自由页链表(偏移量32)存储未使用的页.自由页页数存储在偏移量36.在自由页链表中页有两种类型:主干页和叶子页.文件头指出了自由页链表中的第一个主干页.每一个主干页里含有指向许多叶子页的指针.

![Structure of a freelist](pic/02.DatabaseFileFormat/Figure2-1.StructureOfAFeelist.png)

主干页的格式如下所示:

+ 下一个主干页的页号(4bytes)

+ 本页中含有的叶子页指针个数(4bytes)

+ 0或者更多4bytes叶子页页号

当一个页变为非激活态,SQLite将该页添加到自由页链表中,并不会把页释放给本地文件系统.当你向数据库中添加新的数据的时候,SQLite从自由页链表中取出一页用来存储用户添加的数据.如果自由页链表是空的,SQLite向本地文件系统申请新的页,把新页附加到数据库文件上.

**注意**

vacuum命令可以清空自由页链表.该命令在内存中建立一个数据库的副本(这个副本是通过INSERT INTO…SELECT * FROM…命令实现的).然后在事务系统的保护下,用内存中的副本重写原始数据库.

+ Meta variables

在偏移量40的地方,有15个关于B+树和虚拟机模块的4bytes的整型变量.它们存储许多元信息,包括模式缓存号(偏移量40),每次模式变化会改变这个值.视图层的文件格式信息(偏移量44),page缓存大小(偏移量48),自动清空标志(偏移量52),文本编码(偏移量56,1:UTF-8, 3:UTF-16 LE, 4:UTF-16 BE),用户版本号(偏移量60).在源文件btree.c中有关于这些变量更多的信息.

**NOTE**

SQLite兼容版本3.0.0之前的数据库文件,这意味着任何版本的SQLite可以读写3.0.0之前创建的数据库文件.3.0.0的SQLite可以读写大部分之后版本创建的数据库文件.无论如何,版本3.0.0之后添加了许多新的SQLite3.0.0不理解的特性,如果数据库文件包含这些新的特性,3.0.0及之前的SQLite可能无法识别数据库文件.

在page1中,B+树内部节点之后是文件头.该节点是主目录表的根,即常规数据库的sqlite_master,或者临时数据库的sqlite_temp_master.

**NOTE**

所有的多字节整型变量都是大端存储的,这允许将数据库文件安全地从一个平台移动到另一个平台.
