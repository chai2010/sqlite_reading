



本节将会讲述一些比较常用的指令.

# A

## Affinity

操作码为:

```c
Affinity P1 P2 * P4 *
```

将affinities应用于从寄存器P1开始的P2个寄存器. 个人的理解是将寄存器的值转换为一种近似的表达形式.P4是一个字符串,长度为P2,第n个字符代表从寄存器P1开始的第n个寄存器列的affinity编码.它的可能取值为:

```c
#define SQLITE_AFF_TEXT     'a'
#define SQLITE_AFF_NONE     'b'
#define SQLITE_AFF_NUMERIC  'c'
#define SQLITE_AFF_INTEGER  'd'
#define SQLITE_AFF_REAL     'e'
```



```c
            /* Opcode: Affinity P1 P2 * P4 *
            **
            ** Apply affinities to a range of P2 registers starting with P1.
            ** 将affinities应用于从寄存器P1开始的P2个寄存器. 个人的理解是将寄存器的值转换为
            ** 一种近似的表达形式.
            **
            ** P4 is a string that is P2 characters long. The nth character of the
            ** string indicates the column affinity that should be used for the nth
            ** memory cell in the range.
            ** P4是一个字符串,长度为P2,第n个字符代表从寄存器P1开始的第n个寄存器列的affinity编码.
            */
            case OP_Affinity:
            {
                const char *zAffinity;   /* The affinity to be applied */
                char cAff;               /* A single character of affinity */

                zAffinity = pOp->p4.z;
                assert(zAffinity != 0);
                assert(zAffinity[pOp->p2] == 0);
                pIn1 = &aMem[pOp->p1];
                while ((cAff = *(zAffinity++)) != 0)
                {
                    assert(pIn1 <= &p->aMem[p->nMem]);
                    assert(memIsValid(pIn1));
                    ExpandBlob(pIn1);
                    applyAffinity(pIn1, cAff, encoding);
                    pIn1++;
                }
                break;
            }
```





# B
## Blob

操作码为:

```c
Blob P1 P2 * P4
```

P4指向一个blob数据,长度为P1字节,将这个blob存储在寄存器P2中.

```c
            /* Opcode: Blob P1 P2 * P4
            **
            ** P4 points to a blob of data P1 bytes long.  Store this
            ** blob in register P2.
            ** P4指向一个blob数据,长度为P1字节,将这个blob存储在寄存器P2中
            */
            case OP_Blob:                  /* out2-prerelease */
            {
                sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
                pOut->enc = encoding;
                UPDATE_MAX_BLOBSIZE(pOut);
                break;
            }
```

# C
## Copy

操作码格式为:

```c
Copy P1 P2 * * *
```

拷贝寄存器P1的值到寄存器P2.这条指令做深度拷贝.

```c
            /* Opcode: Copy P1 P2 * * *
            **
            ** Make a copy of register P1 into register P2.
            ** 拷贝寄存器P1的值到寄存器P2
            **
            ** This instruction makes a deep copy of the value.  A duplicate
            ** is made of any string or blob constant.  See also OP_SCopy.
            ** 这条指令做深度拷贝
            */
            case OP_Copy:               /* in1, out2 */
            {
                pIn1 = &aMem[pOp->p1];
                pOut = &aMem[pOp->p2];
                assert(pOut != pIn1);
                sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);
                Deephemeralize(pOut);
                REGISTER_TRACE(pOp->p2, pOut);
                break;
            }
```
## Column

操作码为:

```c
Column P1 P2 P3 P4 P5
```

P1是一个游标,指向用MakeRecord指令构建的一个record.从P1指向的record提取第P2-th列,放入P3寄存器.如果在record中值的个数少于(P2+1),提取出NULL.提取出来的值将会放入寄存器P3. 如果column少于P2个字段,那么提取出NULL,或者,如果P4参数是一个指向Mem实例的指针,使用P4指向的值作为结果(拷贝至P3寄存器).

```c
            /* Opcode: Column P1 P2 P3 P4 P5
            **
            ** Interpret the data that cursor P1 points to as a structure built using
            ** the MakeRecord instruction.  (See the MakeRecord opcode for additional
            ** information about the format of the data.)  Extract the P2-th column
            ** from this record.  If there are less that (P2+1)
            ** values in the record, extract a NULL.
            ** P1是一个游标,指向用MakeRecord指令构建的一个record.从P1指向的record提取第P2-th列
            ** 放入P3寄存器.如果在record中值的个数少于(P2+1),提取出NULL.
            **
            ** The value extracted is stored in register P3.
            ** 提取出来的值将会放入寄存器P3.
            **
            ** If the column contains fewer than P2 fields, then extract a NULL.  Or,
            ** if the P4 argument is a P4_MEM use the value of the P4 argument as
            ** the result.
            ** 如果column少于P2个字段,那么提取出NULL,或者,如果P4参数是一个指向Mem实例的指针,
            ** 使用P4指向的值作为结果(拷贝至P3寄存器).
            **
            ** If the OPFLAG_CLEARCACHE bit is set on P5 and P1 is a pseudo-table cursor,
            ** then the cache of the cursor is reset prior to extracting the column.
            ** The first OP_Column against a pseudo-table after the value of the content
            ** register has changed should have this bit set.
            **
            ** If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 when
            ** the result is guaranteed to only be used as the argument of a length()
            ** or typeof() function, respectively.  The loading of large blobs can be
            ** skipped for length() and all content loading can be skipped for typeof().
            */
            case OP_Column:
            {
                u32 payloadSize;   /* Number of bytes in the record */
                i64 payloadSize64; /* Number of bytes in the record */
                int p1;            /* P1 value of the opcode */
                int p2;            /* column number to retrieve */
                /* 游标 */
                VdbeCursor *pC;    /* The VDBE cursor */
                /* 指向完整的记录 */
                char *zRec;        /* Pointer to complete record-data */
                BtCursor *pCrsr;   /* The BTree cursor */
                /* aType[i]保存着第i列的值类型 */
                u32 *aType;        /* aType[i] holds the numeric type of the i-th column */
                u32 *aOffset;      /* aOffset[i] is offset to start of data for i-th column */
                int nField;        /* number of fields in the record */
                int len;           /* The length of the serialized data for the column */
                int i;             /* Loop counter */
                char *zData;       /* Part of the record being decoded */
                Mem *pDest;        /* Where to write the extracted value */
                Mem sMem;          /* For storing the record being decoded */
                u8 *zIdx;          /* Index into header */
                u8 *zEndHdr;       /* Pointer to first byte after the header */
                u32 offset;        /* Offset into the data */
                u32 szField;       /* Number of bytes in the content of a field */
                int szHdr;         /* Size of the header size field at start of record */
                int avail;         /* Number of bytes of available data */
                u32 t;             /* A type code from the record header */
                Mem *pReg;         /* PseudoTable input register */


                p1 = pOp->p1;
                p2 = pOp->p2;
                pC = 0;
                memset(&sMem, 0, sizeof(sMem));
                pDest = &aMem[pOp->p3]; /* P3寄存器的地址 */
                memAboutToChange(p, pDest);
                zRec = 0;

                /* This block sets the variable payloadSize to be the total number of
                ** bytes in the record.
                **
                ** zRec is set to be the complete text of the record if it is available.
                ** The complete record text is always available for pseudo-tables
                ** If the record is stored in a cursor, the complete record text
                ** might be available in the  pC->aRow cache.  Or it might not be.
                ** If the data is unavailable,  zRec is set to NULL.
                **
                ** We also compute the number of columns in the record.  For cursors,
                ** the number of columns is stored in the VdbeCursor.nField element.
                */
                pC = p->apCsr[p1];
                pCrsr = pC->pCursor; /* 获得游标 */
                if (pCrsr != 0)
                {
                    /* The record is stored in a B-Tree */
                    rc = sqlite3VdbeCursorMoveto(pC);
                    if (rc) goto abort_due_to_error;
                    if (pC->nullRow)
                    {
                        payloadSize = 0; /* 记录的大小为0 */
                    }
                    else if (pC->cacheStatus == p->cacheCtr)
                    {
                        payloadSize = pC->payloadSize;
                        zRec = (char*)pC->aRow;
                    }
                    else if (pC->isIndex)
                    {
                        VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &payloadSize64);
                        payloadSize = (u32)payloadSize64;
                    }
                    else
                    {
                        VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &payloadSize);
                    }
                }
                else if (ALWAYS(pC->pseudoTableReg > 0))
                {
                    pReg = &aMem[pC->pseudoTableReg];
                    payloadSize = pReg->n;
                    zRec = pReg->z;
                    pC->cacheStatus = (pOp->p5 & OPFLAG_CLEARCACHE) ? CACHE_STALE : p->cacheCtr;
                }
                else
                {
                    /* Consider the row to be NULL */
                    payloadSize = 0;
                }

                /* If payloadSize is 0, then just store a NULL.  This can happen because of
                ** nullRow or because of a corrupt database. */
                if (payloadSize == 0)
                {
                    MemSetTypeFlag(pDest, MEM_Null);
                    goto op_column_out;
                }
                if (payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH])
                {
                    goto too_big;
                }
                nField = pC->nField;

                /* Read and parse the table header.  Store the results of the parse
                ** into the record header cache fields of the cursor.
                */
                aType = pC->aType;
                if (pC->cacheStatus == p->cacheCtr)
                {
                    aOffset = pC->aOffset;
                }
                else
                {
                    avail = 0;
                    pC->aOffset = aOffset = &aType[nField];
                    pC->payloadSize = payloadSize;
                    pC->cacheStatus = p->cacheCtr;

                    /* Figure out how many bytes are in the header */
                    if (zRec)
                    {
                        zData = zRec;
                    }
                    else
                    {
                        if (pC->isIndex)
                        {
                            zData = (char*)sqlite3BtreeKeyFetch(pCrsr, &avail);
                        }
                        else
                        {
                            zData = (char*)sqlite3BtreeDataFetch(pCrsr, &avail);
                        }
                        /* If KeyFetch()/DataFetch() managed to get the entire payload,
                        ** save the payload in the pC->aRow cache.  That will save us from
                        ** having to make additional calls to fetch the content portion of
                        ** the record.
                        */
                        if (payloadSize <= (u32)avail)
                        {
                            zRec = zData;
                            pC->aRow = (u8*)zData;
                        }
                        else
                        {
                            pC->aRow = 0;
                        }
                    }
                    /* The following assert is true in all cases except when
                    ** the database file has been corrupted externally.
                    **    assert( zRec!=0 || avail>=payloadSize || avail>=9 ); */
                    szHdr = getVarint32((u8*)zData, offset); /* 头部大小 */

                    /* Make sure a corrupt database has not given us an oversize header.
                    ** Do this now to avoid an oversize memory allocation.
                    **
                    ** Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte
                    ** types use so much data space that there can only be 4096 and 32 of
                    ** them, respectively.  So the maximum header length results from a
                    ** 3-byte type for each of the maximum of 32768 columns plus three
                    ** extra bytes for the header length itself.  32768*3 + 3 = 98307.
                    */
                    if (offset > 98307)
                    {
                        rc = SQLITE_CORRUPT_BKPT;
                        goto op_column_out;
                    }

                    /* Compute in len the number of bytes of data we need to read in order
                    ** to get nField type values.  offset is an upper bound on this.  But
                    ** nField might be significantly less than the true number of columns
                    ** in the table, and in that case, 5*nField+3 might be smaller than offset.
                    ** We want to minimize len in order to limit the size of the memory
                    ** allocation, especially if a corrupt database file has caused offset
                    ** to be oversized. Offset is limited to 98307 above.  But 98307 might
                    ** still exceed Robson memory allocation limits on some configurations.
                    ** On systems that cannot tolerate large memory allocations, nField*5+3
                    ** will likely be much smaller since nField will likely be less than
                    ** 20 or so.  This insures that Robson memory allocation limits are
                    ** not exceeded even for corrupt database files.
                    */
                    len = nField * 5 + 3;
                    if (len > (int)offset) len = (int)offset;

                    /* The KeyFetch() or DataFetch() above are fast and will get the entire
                    ** record header in most cases.  But they will fail to get the complete
                    ** record header if the record header does not fit on a single page
                    ** in the B-Tree.  When that happens, use sqlite3VdbeMemFromBtree() to
                    ** acquire the complete header text.
                    ** 上面的KeyFetch()或者DataFetch()很快,而且大多数时候可以获得整个记录的头部.
                    ** 但是如果记录头没有办法放入一页,这些函数将会失败,如果发生了的话,使用
                    ** sqlite3VdbeMemFromBtree()来获得完整的头部.
                    */
                    if (!zRec && avail < len)
                    {
                        sMem.flags = 0;
                        sMem.db = 0;
                        rc = sqlite3VdbeMemFromBtree(pCrsr, 0, len, pC->isIndex, &sMem);
                        if (rc != SQLITE_OK)
                        {
                            goto op_column_out;
                        }
                        zData = sMem.z;
                    }
                    zEndHdr = (u8 *)&zData[len];
                    zIdx = (u8 *)&zData[szHdr];

                    /* Scan the header and use it to fill in the aType[] and aOffset[]
                    ** arrays.  aType[i] will contain the type integer for the i-th
                    ** column and aOffset[i] will contain the offset from the beginning
                    ** of the record to the start of the data for the i-th column
                    ** 扫描头部,使用它填充aType[]以及aOffset[]数组,aType[i]将会包含第i列的类型
                    ** aOffset[i]记录第i列数据距离记录头部的偏移.
                    */
                    for (i = 0; i < nField; i++)
                    {
                        if (zIdx < zEndHdr)
                        {
                            aOffset[i] = offset; /* 记录下数据的偏移 */
                            if (zIdx[0] < 0x80)
                            {
                                t = zIdx[0];
                                zIdx++;
                            }
                            else
                            {
                                zIdx += sqlite3GetVarint32(zIdx, &t);
                            }
                            aType[i] = t; /* 记录下数据类型 */
                            szField = sqlite3VdbeSerialTypeLen(t); /* 数据长度 */
                            offset += szField; /* 计算数据的偏移 */
                            if (offset < szField)  /* True if offset overflows */
                            {
                                zIdx = &zEndHdr[1];  /* Forces SQLITE_CORRUPT return below */
                                break;
                            }
                        }
                        else
                        {
                            /* If i is less that nField, then there are fewer fields in this
                            ** record than SetNumColumns indicated there are columns in the
                            ** table. Set the offset for any extra columns not present in
                            ** the record to 0. This tells code below to store the default value
                            ** for the column instead of deserializing a value from the record.
                            */
                            aOffset[i] = 0;
                        }
                    }
                    sqlite3VdbeMemRelease(&sMem);
                    sMem.flags = MEM_Null;

                    /* If we have read more header data than was contained in the header,
                    ** or if the end of the last field appears to be past the end of the
                    ** record, or if the end of the last field appears to be before the end
                    ** of the record (when all fields present), then we must be dealing
                    ** with a corrupt database.
                    */
                    if ((zIdx > zEndHdr) || (offset > payloadSize)
                        || (zIdx == zEndHdr && offset != payloadSize))
                    {
                        rc = SQLITE_CORRUPT_BKPT;
                        goto op_column_out;
                    }
                }

                /* Get the column information. If aOffset[p2] is non-zero, then
                ** deserialize the value from the record. If aOffset[p2] is zero,
                ** then there are not enough fields in the record to satisfy the
                ** request.  In this case, set the value NULL or to P4 if P4 is
                ** a pointer to a Mem object.
                ** 获取列信息,如果aOffset[p2]不是0,那么反序列化对应的值,如果是0,那么表示记录中
                ** 没有足够多的字段来满足需求,这种情况下,将值设置为NULL,如果如果P4是一个指向
                ** Mem实例的指针,将值设置为P4的值.
                */
                if (aOffset[p2])
                {
                    if (zRec)
                    {
                        /* This is the common case where the whole row fits on a single page */
                        VdbeMemRelease(pDest);
                        sqlite3VdbeSerialGet((u8 *)&zRec[aOffset[p2]], aType[p2], pDest);
                    }
                    else
                    {
                        /* This branch happens only when the row overflows onto multiple pages */
                        t = aType[p2];
                        if ((pOp->p5 & (OPFLAG_LENGTHARG | OPFLAG_TYPEOFARG)) != 0
                            && ((t >= 12 && (t & 1) == 0) || (pOp->p5 & OPFLAG_TYPEOFARG) != 0)
                           )
                        {
                            /* Content is irrelevant for the typeof() function and for
                            ** the length(X) function if X is a blob.  So we might as well use
                            ** bogus content rather than reading content from disk.  NULL works
                            ** for text and blob and whatever is in the payloadSize64 variable
                            ** will work for everything else. */
                            zData = t < 12 ? (char*)&payloadSize64 : 0;
                        }
                        else
                        {
                            len = sqlite3VdbeSerialTypeLen(t);
                            sqlite3VdbeMemMove(&sMem, pDest);
                            rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len,  pC->isIndex,
                                                         &sMem);
                            if (rc != SQLITE_OK)
                            {
                                goto op_column_out;
                            }
                            zData = sMem.z;
                        }
                        /* 解析并转换磁盘中读取出的数据, 结果放入pDest */
                        sqlite3VdbeSerialGet((u8*)zData, t, pDest);
                    }
                    pDest->enc = encoding;
                }
                else /* 记录中没有足够的字段 */
                {
                    if (pOp->p4type == P4_MEM)
                    {
                        sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, MEM_Static);
                    }
                    else
                    {
                        MemSetTypeFlag(pDest, MEM_Null);
                    }
                }

                /* If we dynamically allocated space to hold the data (in the
                ** sqlite3VdbeMemFromBtree() call above) then transfer control of that
                ** dynamically allocated space over to the pDest structure.
                ** This prevents a memory copy.
                */
                if (sMem.zMalloc)
                {
                    pDest->flags &= ~(MEM_Ephem | MEM_Static);
                    pDest->flags |= MEM_Term;
                    pDest->z = sMem.z;
                    pDest->zMalloc = sMem.zMalloc;
                }
                rc = sqlite3VdbeMemMakeWriteable(pDest);
            op_column_out:
                UPDATE_MAX_BLOBSIZE(pDest);
                REGISTER_TRACE(pOp->p3, pDest);
                break;
            }
```
## Clear

操作码为:

```c
Clear P1 P2 P3
```

删除数据库表/索引的所有内容,它在数据库文件中的root page由P1参数提供.不同于Destroy,并不移除数据库文件中的表/索引.

如果P2 == 0,那么表在主数据库文件中,如果P2==1,表在辅助数据库文件中(它用来存储使用 CREATE TEMPORARY TABLE命令创建的表).

如果P3非零,那么对应的表肯定是int类型的key(一个SQL表,不是索引).在这种情况下,变化的行数应当增加表中被清理的行的计数值.
如果P3大于0,那么存储在寄存器P3中的值应当加上表中被清理行的计数值.

```c
            /* Opcode: Clear P1 P2 P3
            **
            ** Delete all contents of the database table or index whose root page
            ** in the database file is given by P1.  But, unlike Destroy, do not
            ** remove the table or index from the database file.
            ** 删除数据库表/索引的所有内容,它在数据库文件中的root page由P1参数提供.不同于Destroy
            ** 并不移除数据库文件中的表/索引.
            **
            ** The table being clear is in the main database file if P2==0.  If
            ** P2==1 then the table to be clear is in the auxiliary database file
            ** 如果P2==0,那么表在主数据库文件中,如果P2==1,表在辅助数据库文件中(它用来存储使用
            ** CREATE TEMPORARY TABLE命令创建的表)
            **
            ** If the P3 value is non-zero, then the table referred to must be an
            ** intkey table (an SQL table, not an index). In this case the row change
            ** count is incremented by the number of rows in the table being cleared.
            ** If P3 is greater than zero, then the value stored in register P3 is
            ** also incremented by the number of rows in the table being cleared.
            ** 如果P3非零,那么对应的表肯定是int类型的key(一个SQL表,不是索引).在这种情况下,
            ** 变化的行数应当增加表中被清理的行的计数值.
            ** 如果P3大于0,那么存储在寄存器P3中的值应当加上表中被清理行的计数值.
            ** 
            ** See also: Destroy
            */
            case OP_Clear:
            {
                int nChange;
                nChange = 0;
                rc = sqlite3BtreeClearTable(
                         db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0));
                if (pOp->p3)
                {
                    p->nChange += nChange;
                    if (pOp->p3 > 0)
                    {
                        memAboutToChange(p, &aMem[pOp->p3]);
                        aMem[pOp->p3].u.i += nChange;
                    }
                }
                break;
            }

```
## CreateTable && CreateIndex

CreateTable操作码为:

```c
CreateTable P1 P2 * * *
```

创建一张新表,P1是数据库的索引.将新表的root page页号写入寄存器P2.表和索引的不同之处在于: 一张表必须要有4字节的整数key,可以拥有任意的数据,一个索引有任意的key,没有数据.

CreateIndex的操作码为:

```c
CreateIndex P1 P2 * * *
```

创建一个索引,P1指代数据库,创建完成后,root page的页号将会写入寄存器P2.

```c
            /* Opcode: CreateTable P1 P2 * * *
            **
            ** Allocate a new table in the main database file if P1==0 or in the
            ** auxiliary database file if P1==1 or in an attached database if
            ** P1>1.  Write the root page number of the new table into
            ** register P2
            ** 创建一张新表,P1是数据库的索引.将新表的root page页号写入寄存器P2
            **
            ** The difference between a table and an index is this:  A table must
            ** have a 4-byte integer key and can have arbitrary data.  An index
            ** has an arbitrary key but no data.
            ** 表和索引的不同之处在于: 一张表必须要有4字节的整数key,可以拥有任意的数据,一个索引有任意的key,没有数据.
            */
            /* Opcode: CreateIndex P1 P2 * * *
            **
            ** Allocate a new index in the main database file if P1==0 or in the
            ** auxiliary database file if P1==1 or in an attached database if
            ** P1>1.  Write the root page number of the new table into
            ** register P2.
            ** 创建一个索引,P1指代数据库,创建完成后,root page的页号将会写入寄存器P2
            */
            case OP_CreateIndex:            /* out2-prerelease */
            case OP_CreateTable:            /* out2-prerelease */
            {
                int pgno;
                int flags;
                Db *pDb;

                pgno = 0;
                pDb = &db->aDb[pOp->p1]; /* 获得对应的数据库 */
                if (pOp->opcode == OP_CreateTable)
                {
                    /* flags = BTREE_INTKEY; */
                    flags = BTREE_INTKEY;
                }
                else
                {
                    flags = BTREE_BLOBKEY;
                }
                rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, flags); /* 创建表 */
                pOut->u.i = pgno; /* 记录下页号 */
                break;
            }

```

# D

## Destroy

操作码为:

```c
Destroy P1 P2 P3 * *
```

删除整个数据库表/索引,它在数据库中的root page由P1提供.

如果P3 == 0,那么表在主数据库文件中,如果P3==1,表在辅助数据库文件中(它用来存储使用CREATE TEMPORARY TABLE命令创建的表).

```c
           /* Opcode: Destroy P1 P2 P3 * *
            **
            ** Delete an entire database table or index whose root page in the database
            ** file is given by P1.
            ** 删除整个数据库表/索引,它在数据库中的root page由P1提供.
            **
            ** The table being destroyed is in the main database file if P3==0.  If
            ** P3==1 then the table to be clear is in the auxiliary database file
            ** that is used to store tables create using CREATE TEMPORARY TABLE.
            ** 如果P3==0,那么表在主数据库文件中,如果P3==1,表在辅助数据库文件中(它用来存储使用
            ** CREATE TEMPORARY TABLE命令创建的表)
            **
            ** See also: Clear
            */
            case OP_Destroy:       /* out2-prerelease */
            {
                int iMoved;
                int iCnt;
                Vdbe *pVdbe;
                int iDb;
#ifndef SQLITE_OMIT_VIRTUALTABLE
                iCnt = 0;
                for (pVdbe = db->pVdbe; pVdbe; pVdbe = pVdbe->pNext)
                {
                    if (pVdbe->magic == VDBE_MAGIC_RUN && pVdbe->inVtabMethod < 2 && pVdbe->pc >= 0)
                    {
                        iCnt++;
                    }
                }
#else
                iCnt = db->activeVdbeCnt;
#endif
                pOut->flags = MEM_Null;
                if (iCnt > 1)
                {
                    rc = SQLITE_LOCKED;
                    p->errorAction = OE_Abort;
                }
                else
                {
                    iDb = pOp->p3;
                    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved); /* 删除表 */
                    pOut->flags = MEM_Int;
                    pOut->u.i = iMoved;
                }
                break;
            }
```
## Delete

操作码为:

```c
Delete P1 P2 * P4 *
```

删除P1游标当前指向的记录.游标将会指向被删除记录的后/前面的记录.如果P2中带有OPFLAG_NCHANGE标记,那么行的change count将会递增(否则不会).P1不能是一张伪表,它应当是拥有许多行的真表.

```c
            /* Opcode: Delete P1 P2 * P4 *
            **
            ** Delete the record at which the P1 cursor is currently pointing.
            ** 删除P1游标当前指向的记录.
            **
            ** The cursor will be left pointing at either the next or the previous
            ** record in the table. If it is left pointing at the next record, then
            ** the next Next instruction will be a no-op.  Hence it is OK to delete
            ** a record from within an Next loop.
            ** 游标将会指向被删除记录的后/前面的记录.
            **
            ** If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is
            ** incremented (otherwise not).
            ** 如果P2中带有OPFLAG_NCHANGE标记,那么行的change count将会递增(否则不会).
            **
            ** P1 must not be pseudo-table.  It has to be a real table with
            ** multiple rows.
            ** P1不能是一张伪表,它应当是拥有许多行的真表.
            **
            ** If P4 is not NULL, then it is the name of the table that P1 is
            ** pointing to.  The update hook will be invoked, if it exists.
            ** If P4 is not NULL then the P1 cursor must have been positioned
            ** using OP_NotFound prior to invoking this opcode.
            ** 如果P4不为NULL,那么它应是P1所指向表的名称.update回调将会被调用,如果有的话.
            */
            case OP_Delete:
            {
                i64 iKey;
                VdbeCursor *pC;

                iKey = 0;
                pC = p->apCsr[pOp->p1];

                /* If the update-hook will be invoked, set iKey to the rowid of the
                ** row being deleted.
                */
                if (db->xUpdateCallback && pOp->p4.z)
                {
                    iKey = pC->lastRowid;
                }

                /* The OP_Delete opcode always follows an OP_NotExists or OP_Last or
                ** OP_Column on the same table without any intervening operations that
                ** might move or invalidate the cursor.  Hence cursor pC is always pointing
                ** to the row to be deleted and the sqlite3VdbeCursorMoveto() operation
                ** below is always a no-op and cannot fail.  We will run it anyhow, though,
                ** to guard against future changes to the code generator.
                ** OP_Delete操作码之后,紧跟着操作在同一张表上的OP_NotExists或者OP_Lase或者OP_Column.
                ** 没有任何干预操作会使得光标移动或者无效.
                ** 因此游标pC总是指向要删除的行,并且下面的sqlite3CursorMoveto()什么也不干,而且不可能失败.
                ** 我们总是要跑,为了应对未来的改动.
                **/
                rc = sqlite3VdbeCursorMoveto(pC);
                if (NEVER(rc != SQLITE_OK)) goto abort_due_to_error;

                sqlite3BtreeSetCachedRowid(pC->pCursor, 0);
                rc = sqlite3BtreeDelete(pC->pCursor);
                pC->cacheStatus = CACHE_STALE;

                /* Invoke the update-hook if required. */
                if (rc == SQLITE_OK && db->xUpdateCallback && pOp->p4.z)
                {
                    const char *zDb = db->aDb[pC->iDb].zName;
                    const char *zTbl = pOp->p4.z;
                    db->xUpdateCallback(db->pUpdateArg, SQLITE_DELETE, zDb, zTbl, iKey);
                }
                if (pOp->p2 & OPFLAG_NCHANGE) p->nChange++;
                break;
            }
```

# E

## Expire

操作码为:

```c
Opcode: Expire P1 * * * *
```

使得预编译的指令变得过去,一个过期的指令如果被执行过(比如通过sqlite3_step()),则会失败，错误代码为 SQLITE_SCHEMA.

如果P1为0,那么所有的SQL指令都过去,如果P1为非0,那么仅有当前正在执行的指令受影响.

```c
            /* Opcode: Expire P1 * * * *
            **
            ** Cause precompiled statements to become expired. An expired statement
            ** fails with an error code of SQLITE_SCHEMA if it is ever executed
            ** (via sqlite3_step()).
            **
            ** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,
            ** then only the currently executing statement is affected.
            */
            case OP_Expire:
            {
                if (!pOp->p1)
                {
                    sqlite3ExpirePreparedStatements(db);
                }
                else
                {
                    p->expired = 1;
                }
                break;
            }
```



# F
## Found && NotFound

Found的操作码为:

```c
Found P1 P2 P3 P4 *
```

如果P4为0,那么P3指向一个blob(由MakeRecord指令创建),如果P4>0,那么从P3开始的长度为P4的寄存器数组构成一个unpacked record.P1是一个游标,指向btree,如果由P3以及P4指定的record在P1指向的表中可以找到,那么跳转到P2指令处执行.

NotFound的操作码为:

```c
NotFound P1 P2 P3 P4 *
```

和Found指令一致,如果由P3以及P4指定的record在P1指向的表中找不到,那么跳转到P2指令处执行.

```c
            /* Opcode: Found P1 P2 P3 P4 *
            **
            ** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
            ** P4>0 then register P3 is the first of P4 registers that form an unpacked
            ** record.
            ** 如果P4为0,那么P3指向一个blob(由MakeRecord指令创建),如果P4>0,那么从P3开始的长度为P4
            ** 的寄存器数组构成一个unpacked record.
            **
            ** Cursor P1 is on an index btree.  If the record identified by P3 and P4
            ** is a prefix of any entry in P1 then a jump is made to P2 and
            ** P1 is left pointing at the matching entry.
            ** P1游标在索引btree之上,如果由P3以及P4指定的record在P1指向的表中已经存在,那么跳转到P2指令处执行.
            */
            /* Opcode: NotFound P1 P2 P3 P4 *
            **
            ** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
            ** P4>0 then register P3 is the first of P4 registers that form an unpacked
            ** record.
            ** 如果P4为0,那么P3指向一个blob(由MakeRecord指令创建),如果P4>0,那么从P3开始的长度为P4
            ** 的寄存器数组构成一个unpacked record.
            **
            ** Cursor P1 is on an index btree.  If the record identified by P3 and P4
            ** is not the prefix of any entry in P1 then a jump is made to P2.  If P1
            ** does contain an entry whose prefix matches the P3/P4 record then control
            ** falls through to the next instruction and P1 is left pointing at the
            ** matching entry.
            */
            case OP_NotFound:       /* jump, in3 */
            case OP_Found:          /* jump, in3 */
            {
                int alreadyExists;
                VdbeCursor *pC;
                int res;
                char *pFree;
                UnpackedRecord *pIdxKey;
                UnpackedRecord r;
                char aTempRec[ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem) * 3 + 7];
                alreadyExists = 0;
                pC = p->apCsr[pOp->p1];
                assert(pC != 0);
                pIn3 = &aMem[pOp->p3];
                if (ALWAYS(pC->pCursor != 0))
                {
                    if (pOp->p4.i > 0) /* 列个数 */
                    {
                        r.pKeyInfo = pC->pKeyInfo;
                        r.nField = (u16)pOp->p4.i; /* 字段个数 */
                        r.aMem = pIn3;
                        r.flags = UNPACKED_PREFIX_MATCH;
                        pIdxKey = &r;
                    }
                    else
                    {
                        pIdxKey = sqlite3VdbeAllocUnpackedRecord(
                                      pC->pKeyInfo, aTempRec, sizeof(aTempRec), &pFree
                                  );
                        if (pIdxKey == 0) goto no_mem;
                        sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, pIdxKey);
                        pIdxKey->flags |= UNPACKED_PREFIX_MATCH;
                    }
                    /* 根据key,到数据库中寻找记录 */
                    rc = sqlite3BtreeMovetoUnpacked(pC->pCursor, pIdxKey, 0, 0, &res);
                    if (pOp->p4.i == 0)
                    {
                        sqlite3DbFree(db, pFree);
                    }
                    if (rc != SQLITE_OK)
                    {
                        break;
                    }
                    alreadyExists = (res == 0); /* 记录是否在表中已经存在 */
                    pC->deferredMoveto = 0;
                    pC->cacheStatus = CACHE_STALE;
                }
                if (pOp->opcode == OP_Found)
                { /* 为什么pc为P2-1,很简单,下一条指令执行之前,pc会+1 */
                    if (alreadyExists) pc = pOp->p2 - 1; /* 存在,跳转到P2指令执行 */
                }
                else
                {
                    if (!alreadyExists) pc = pOp->p2 - 1; /* 不存在,跳转到P2指令执行 */
                }
                break;
            }
```

# G

## Goto

操作码为:

```c
Goto * P2 * * *
```

无条件跳转到地址P2.

```c
            /* Opcode:  Goto * P2 * * *
            **
            ** An unconditional jump to address P2.
            ** The next instruction executed will be
            ** the one at index P2 from the beginning of
            ** the program.
            ** 无条件跳转到P2
            */
            case OP_Goto:               /* jump */
            {
                pc = pOp->p2 - 1;
                break;
            }
```

## Gosub

操作码为:

```c
Gosub P1 P2 * * *
```

将当前的地址(pc)写入寄存器P1,然后跳转到P2.

```c
            /* Opcode:  Gosub P1 P2 * * *
            **
            ** Write the current address onto register P1
            ** and then jump to address P2.
            ** 将当前的地址(pc)写入寄存器P1,然后跳转到P2
            */
            case OP_Gosub:              /* jump */
            {
                pIn1 = &aMem[pOp->p1];
                memAboutToChange(p, pIn1);
                pIn1->flags = MEM_Int; /* 记录下指令 */
                pIn1->u.i = pc;
                pc = pOp->p2 - 1; /* 跳转到p2,继续执行 */
                break;
            }
```

# H

## HaltIfNull && Halt

HaltIfNull操作码为:

```c
HaltIfNull  P1 P2 P3 P4 *
```

检查寄存器P3中的值,如果为NULL,使用参数p1, p2,p4作为halt指令的参数(如果halt指令存在的话).如果P3非空,此条指令什么也不做.

Halt操作码为:

```c
Halt P1 P2 * P4 *
```

立即退出,全部打开的游标等立即关闭.P1是sqlite3_exec()/sqlite3_reset()/sqlite3_finalize()的返回码,对于一个正常的halt,P1的值应当是SQLITE_OK(0),如果确实有错误,那么它就是其他值.如果P1!=0,那么P2用于决定是否回滚事务.如果P2==OE_Fail,不需要回滚,OE_Rollback则需要回滚.

如果P4不为null,那么它是一个错误消息串.

```c
            /* Opcode:  HaltIfNull  P1 P2 P3 P4 *
            **
            ** Check the value in register P3.  If it is NULL then Halt using
            ** parameter P1, P2, and P4 as if this were a Halt instruction.  If the
            ** value in register P3 is not NULL, then this routine is a no-op.
            ** 检查寄存器P3中的值,如果为NULL,使用参数p1, p2,p4作为halt指令的参数,如果halt指令存在
            ** 的话.如果P3非空,此条指令什么也不做.
            */
            case OP_HaltIfNull:        /* in3 */
            {
                pIn3 = &aMem[pOp->p3];
                if ((pIn3->flags & MEM_Null) == 0) break;
                /* Fall through into OP_Halt */
                /* 直接掉落到OP_Halt */
            }
            /* Opcode:  Halt P1 P2 * P4 *
            **
            ** 立即退出,全部打开的游标等立即关闭.
            **
            ** P1是sqlite3_exec()/sqlite3_reset()/sqlite3_finalize()的返回码,对于一个正常的halt,
            ** P1的值应当是SQLITE_OK(0),如果确实有错误,那么它就是其他值.如果P1!=0,那么P2用于决定是否回滚事务.
            ** 如果P2==OE_Fail,不需要回滚,OE_Rollback则需要回滚.
            **
            ** If P4 is not null then it is an error message string.
            ** 如果P4不为null,那么它是一个错误消息串.
            **
            ** There is an implied "Halt 0 0 0" instruction inserted at the very end of
            ** every program.  So a jump past the last instruction of the program
            ** is the same as executing Halt.
            */
            case OP_Halt:
            {
                if (pOp->p1 == SQLITE_OK && p->pFrame)
                {
                    VdbeFrame *pFrame = p->pFrame; /* 停止子程序,将控制权转移给父程序 */
                    p->pFrame = pFrame->pParent;
                    p->nFrame--;
                    sqlite3VdbeSetChanges(db, p->nChange);
                    pc = sqlite3VdbeFrameRestore(pFrame);
                    lastRowid = db->lastRowid;
                    if (pOp->p2 == OE_Ignore)
                    {
                        /* Instruction pc is the OP_Program that invoked the sub-program
                        ** currently being halted. If the p2 instruction of this OP_Halt
                        ** instruction is set to OE_Ignore, then the sub-program is throwing
                        ** an IGNORE exception. In this case jump to the address specified
                        ** as the p2 of the calling OP_Program. 
                        * 指令pc是调用子程序的OP_Program指令的地址,如果Halt指令对应的p2为OE_Ignore,那么子程序
                        ** 抛出一个IGNORE异常,这种情况下,跳转到p2指示的地址运行.
                        */
                        pc = p->aOp[pc].p2 - 1;
                    }
                    aOp = p->aOp;
                    aMem = p->aMem;
                    break;
                }

                p->rc = pOp->p1;
                p->errorAction = (u8)pOp->p2;
                p->pc = pc;
                if (pOp->p4.z) /* p4是一个错误消息串 */
                {
                    sqlite3SetString(&p->zErrMsg, db, "%s", pOp->p4.z);
                    sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pc, p->zSql, pOp->p4.z);
                }
                else if (p->rc)
                {
                    sqlite3_log(pOp->p1, "constraint failed at %d in [%s]", pc, p->zSql);
                }
                rc = sqlite3VdbeHalt(p);
                if (rc == SQLITE_BUSY)
                {
                    p->rc = rc = SQLITE_BUSY;
                }
                else
                {
                    rc = p->rc ? SQLITE_ERROR : SQLITE_DONE;
                }
                goto vdbe_return;
            }
```

# I

## INIT

Programs contain a single instance of this opcode as the very first opcode.If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().If P2 is not zero, jump to instruction P2.Increment the value of P1 so that [Once](https://www.sqlite.org/opcode.html#Once) opcodes will jump the first time they are evaluated for this run.If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.

如果P2不为零,那么跳转到指令P2处执行.

如果P3不为零,当虚拟机遭遇SQLITE_CORRUPT错误的时候,会跳转到指令P3处执行.

## Integer

操作码为:

```c
Integer P1 P2 * * *
```



将P1(整数)的值,写入寄存器P2

```c
            /* Opcode: Integer P1 P2 * * *
            **
            ** The 32-bit integer value P1 is written into register P2.
            ** 将P1(整数)的值,写入寄存器P2
            */
            case OP_Integer:           /* out2-prerelease */
            {
                pOut->u.i = pOp->p1;
                break;
            }
```

## Int64

操作码为:

```c
Int64 * P2 * P4 *
```

P4是一个指向64-bit的整数值,将值写入寄存器P2.

```c
            /* Opcode: Int64 * P2 * P4 *
            **
            ** P4 is a pointer to a 64-bit integer value.
            ** Write that value into register P2.
            ** P4是一个指向64-bit的整数值,将值写入寄存器P2
            */
            case OP_Int64:             /* out2-prerelease */
            {
                pOut->u.i = *pOp->p4.pI64;
                break;
            }
```
## IdxDelete

操作码为:

```c
IdxDelete P1 P2 P3 * *
```

从寄存器P2到寄存器P3中的值构成一个unpacked index key,此操作码移除游标P1指向的entry.

```c
            /* Opcode: IdxDelete P1 P2 P3 * *
            **
            ** The content of P3 registers starting at register P2 form
            ** an unpacked index key. This opcode removes that entry from the
            ** index opened by cursor P1.
            ** 从寄存器P2到寄存器P3中的值构成一个unpacked index key,此操作码移除游标P1
            ** 指向的entry
            */
            case OP_IdxDelete:
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                int res;
                UnpackedRecord r;

                pC = p->apCsr[pOp->p1];
                pCrsr = pC->pCursor;
                if (ALWAYS(pCrsr != 0))
                {
                    r.pKeyInfo = pC->pKeyInfo;
                    r.nField = (u16)pOp->p3;
                    r.flags = 0;
                    r.aMem = &aMem[pOp->p2];
                    /* 根据key移动游标 */
                    rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
                    if (rc == SQLITE_OK && res == 0)
                    {
                        rc = sqlite3BtreeDelete(pCrsr); /* 找到了才进行删除 */
                    }
                    pC->cacheStatus = CACHE_STALE;
                }
                break;
            }

```
## IdxInsert

操作码为:

```c
IdxInsert P1 P2 P3 * P5
```

寄存器P2持有一个通过MakeRecord指令创建的SQL index key, 此操作码将key通过游标P1写入entry的数据为nil(空).

P3是一个标记,用于给b-tree层提供信息,插入很可能是追加.

```c
            /* Opcode: IdxInsert P1 P2 P3 * P5
            **
            ** Register P2 holds an SQL index key made using the
            ** MakeRecord instructions.  This opcode writes that key
            ** into the index P1.  Data for the entry is nil.
            ** 寄存器P2持有一个通过MakeRecord指令创建的SQL index key, 此操作码将key通过游标P1写入
            ** entry的数据为nil(空)
            **
            ** P3 is a flag that provides a hint to the b-tree layer that this
            ** insert is likely to be an append.
            ** P3是一个标记,用于给b-tree层提供信息,插入很可能是追加.
            **
            ** This instruction only works for indices.  The equivalent instruction
            ** for tables is OP_Insert.
            */
            case OP_SorterInsert:       /* in2 */
#ifdef SQLITE_OMIT_MERGE_SORT
                pOp->opcode = OP_IdxInsert;
#endif
            case OP_IdxInsert:          /* in2 */
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                int nKey;
                const char *zKey;

                pC = p->apCsr[pOp->p1];
                pIn2 = &aMem[pOp->p2];
                pCrsr = pC->pCursor;
                if (ALWAYS(pCrsr != 0))
                {
                    rc = ExpandBlob(pIn2);
                    if (rc == SQLITE_OK)
                    {
                        if (isSorter(pC))
                        {
                            rc = sqlite3VdbeSorterWrite(db, pC, pIn2);
                        }
                        else
                        {
                            nKey = pIn2->n;
                            zKey = pIn2->z;
                            /* 插入数据,仅有key,没有data */
                            rc = sqlite3BtreeInsert(pCrsr, zKey, nKey, "", 0, 0, pOp->p3,
                                                    ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0));
                            pC->cacheStatus = CACHE_STALE;
                        }
                    }
                }
                break;
            }

```
## Insert && InsertInt

Inserrt的操作码为:

```c
InsertInt P1 P2 P3 P4 P5
```

往游标P1指向的表写入一个entry,如果表中不存在,那么会插入,如果存在,就会覆写.数据是Blob类型,存储在寄存器P2之中.Key被存储在寄存器P3之中,key的类型为int.如果P5设置了OPFLAG_NCHANGE标记,那么行的change count会递增,如果OPFLAG_LASTROWID标记被设置,rowid被存储起来.

InsertInt的操作码为:

```c
InsertInt P1 P2 P3 P4 P5
```

类似于Insert.

```c
            /* Opcode: Insert P1 P2 P3 P4 P5
            **
            ** Write an entry into the table of cursor P1.  A new entry is
            ** created if it doesn't already exist or the data for an existing
            ** entry is overwritten.  The data is the value MEM_Blob stored in register
            ** number P2. The key is stored in register P3. The key must
            ** be a MEM_Int.
            ** 往游标P1指向的表写入一个entry,如果表中不存在,那么会插入,如果存在,就会覆写.
            ** 数据是Blob类型,存储在寄存器P2之中.
            ** Key被存储在寄存器P3之中,key的类型为int.
            **
            ** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is
            ** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,
            ** then rowid is stored for subsequent return by the
            ** sqlite3_last_insert_rowid() function (otherwise it is unmodified).
            ** 如果P5设置了OPFLAG_NCHANGE标记,那么行的change count会递增,如果OPFLAG_LASTROWID标记
            ** 被设置,rowid被存储起来.
            **
            ** If the OPFLAG_USESEEKRESULT flag of P5 is set and if the result of
            ** the last seek operation (OP_NotExists) was a success, then this
            ** operation will not attempt to find the appropriate row before doing
            ** the insert but will instead overwrite the row that the cursor is
            ** currently pointing to.  Presumably, the prior OP_NotExists opcode
            ** has already positioned the cursor correctly.  This is an optimization
            ** that boosts performance by avoiding redundant seeks.
            ** 如果P5的OFPLAG_USESEEKRESULT标记被设置,而且上一次seek操作的结果是成功的,那么这个
            ** 操作将会尝试寻找和恰当的行在做插入操作之前.
            **
            ** If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an
            ** UPDATE operation.  Otherwise (if the flag is clear) then this opcode
            ** is part of an INSERT operation.  The difference is only important to
            ** the update hook.
            ** 如果OPFLAG_ISUPDATE标记被设置,那么这个操作是UPDATE的一部分,否则,这个操作是INSERT
            ** 的一部分,这个差别对应updte回调来说很重要.
            **
            ** Parameter P4 may point to a string containing the table-name, or
            ** may be NULL. If it is not NULL, then the update-hook
            ** (sqlite3.xUpdateCallback) is invoked following a successful insert.
            ** 参数P4或许指向一个包含着表名的字符串,或许为空.
            **
            ** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
            ** allocated, then ownership of P2 is transferred to the pseudo-cursor
            ** and register P2 becomes ephemeral.  If the cursor is changed, the
            ** value of register P2 will then change.  Make sure this does not
            ** cause any problems.)
            **
            ** This instruction only works on tables.  The equivalent instruction
            ** for indices is OP_IdxInsert.
            ** 这条指令只在表上运行,在索引上执行的类似指令为OP_IdxInsert.
            */
            /* Opcode: InsertInt P1 P2 P3 P4 P5
            **
            ** This works exactly like OP_Insert except that the key is the
            ** integer value P3, not the value of the integer stored in register P3.
            */
            case OP_Insert:
            case OP_InsertInt:
            {
                /* pData指向需要插入的数据 */
                Mem *pData;       /* MEM cell holding data for the record to be inserted */
                Mem *pKey;        /* MEM cell holding key  for the record */
                i64 iKey;         /* The integer ROWID or key for the record to be inserted */
                VdbeCursor *pC;   /* Cursor to table into which insert is written */
                int nZero;        /* Number of zero-bytes to append */
                int seekResult;   /* Result of prior seek or 0 if no USESEEKRESULT flag */
                const char *zDb;  /* database name - used by the update hook */
                const char *zTbl; /* Table name - used by the opdate hook */
                int op;           /* Opcode for update hook: SQLITE_UPDATE or SQLITE_INSERT */

                pData = &aMem[pOp->p2];
                pC = p->apCsr[pOp->p1]; /* 获取p1指向的游标 */

                if (pOp->opcode == OP_Insert) /* 如果需要进行插入操作 */
                {
                    pKey = &aMem[pOp->p3];
                    iKey = pKey->u.i; /* int类型的key值 */
                }
                else
                {
                    iKey = pOp->p3;
                }

                if (pOp->p5 & OPFLAG_NCHANGE) p->nChange++;
                if (pOp->p5 & OPFLAG_LASTROWID) db->lastRowid = lastRowid = iKey;
                if (pData->flags & MEM_Null)
                {
                    pData->z = 0;
                    pData->n = 0;
                }
                else
                {
                    assert(pData->flags & (MEM_Blob | MEM_Str));
                }
                seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                if (pData->flags & MEM_Zero)
                {
                    nZero = pData->u.nZero;
                }
                else
                {
                    nZero = 0;
                }
                sqlite3BtreeSetCachedRowid(pC->pCursor, 0);
                /* 执行数据插入 */
                rc = sqlite3BtreeInsert(pC->pCursor, 0, iKey,
                                        pData->z, pData->n, nZero,
                                        pOp->p5 & OPFLAG_APPEND, seekResult
                                       );
                pC->rowidIsValid = 0;
                pC->deferredMoveto = 0;
                pC->cacheStatus = CACHE_STALE;

                /* Invoke the update-hook if required. */
                if (rc == SQLITE_OK && db->xUpdateCallback && pOp->p4.z)
                {
                    zDb = db->aDb[pC->iDb].zName;
                    zTbl = pOp->p4.z;
                    op = ((pOp->p5 & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT);
                    db->xUpdateCallback(db->pUpdateArg, op, zDb, zTbl, iKey);
                }
                break;
            }
```

## Is_Null

操作码为:

```c
 IsNull P1 P2 * * *
```

如果寄存器P1的值为NULL的话,跳转到指令P2处运行.

```c
            /* Opcode: IsNull P1 P2 * * *
            **
            ** Jump to P2 if the value in register P1 is NULL.
            ** 如果寄存器P1的值为NULL的话,跳转到指令P2处运行.
            */
            case OP_IsNull:              /* same as TK_ISNULL, jump, in1 */
            {
                pIn1 = &aMem[pOp->p1];
                if ((pIn1->flags & MEM_Null) != 0)
                {
                    pc = pOp->p2 - 1;
                }
                break;
            }
```

## IdxGE && IdxLT

IdxGE操作码为:

```c
IdxGE P1 P2 P3 P4 P5
```

从寄存器P3开始的P4个寄存器构成一个unpacked index key(除了ROWID),将这个key和游标P1当前指向的记录的key进行比较,忽略游标P1指向索引记录的ROWID.

如果游标P1指向的索引记录要大于或者等于指令提供的key,那么跳转到P2指令,否则继续往下执行.

如果P5非0,那么在开始比较之前,key值将会增加一个epsilon,这会使得操作码很像IdxGt,除了如果从寄存器P3开始的key是游标P1指向的记录的key的前缀,那么IdxGT结果为false,但是IdxGE为true.

IdxLT的操作码为:

```c
IdxLT P1 P2 P3 P4 P5
```

从寄存器P3开始的P4个寄存器构成一个unpacked index key(除了ROWID),将这个key和游标P1当前指向的记录的key进行比较,忽略游标P1指向索引记录的ROWID.

如果游标P1指向的索引记录要小于指令提供的key,那么跳转到P2指令,否则继续往下执行.

如果P5非0,那么在开始比较之前,key值将会减少一个epsilon,这会使得操作码很像IdxLE.

```c
            /* Opcode: IdxGE P1 P2 P3 P4 P5
            **
            ** The P4 register values beginning with P3 form an unpacked index
            ** key that omits the ROWID.  Compare this key value against the index
            ** that P1 is currently pointing to, ignoring the ROWID on the P1 index.
            ** 从寄存器P3开始的P4个寄存器构成一个unpacked index key(除了ROWID),将这个key
            ** 和游标P1当前指向的记录的key进行比较,忽略游标P1指向索引记录的ROWID.
            **
            ** If the P1 index entry is greater than or equal to the key value
            ** then jump to P2.  Otherwise fall through to the next instruction.
            ** 如果游标P1指向的索引记录要大于或者等于指令提供的key,那么跳转到P2指令,否则继续往下执行.
            **
            ** If P5 is non-zero then the key value is increased by an epsilon
            ** prior to the comparison.  This make the opcode work like IdxGT except
            ** that if the key from register P3 is a prefix of the key in the cursor,
            ** the result is false whereas it would be true with IdxGT.
            ** 如果P5非0,那么在开始比较之前,key值将会增加一个epsilon,这会使得操作码很像IdxGt,除了
            ** 如果从寄存器P3开始的key是游标P1指向的记录的key的前缀,那么IdxGT结果为false,但是IdxGE
            ** 为true.
            */
            /* Opcode: IdxLT P1 P2 P3 P4 P5
            **
            ** The P4 register values beginning with P3 form an unpacked index
            ** key that omits the ROWID.  Compare this key value against the index
            ** that P1 is currently pointing to, ignoring the ROWID on the P1 index.
            ** 从寄存器P3开始的P4个寄存器构成一个unpacked index key(除了ROWID),将这个key
            ** 和游标P1当前指向的记录的key进行比较,忽略游标P1指向索引记录的ROWID.
            **
            ** If the P1 index entry is less than the key value then jump to P2.
            ** Otherwise fall through to the next instruction.
            ** 如果游标P1指向的索引记录要小于指令提供的key,那么跳转到P2指令,否则继续往下执行.
            **
            ** If P5 is non-zero then the key value is increased by an epsilon prior
            ** to the comparison.  This makes the opcode work like IdxLE.
            ** 如果P5非0,那么在开始比较之前,key值将会减少一个epsilon,这会使得操作码很像IdxLE
            */
            case OP_IdxLT:          /* jump */
            case OP_IdxGE:          /* jump */
            {
                VdbeCursor *pC;
                int res;
                UnpackedRecord r;

                pC = p->apCsr[pOp->p1];
                if (ALWAYS(pC->pCursor != 0))
                {
                    r.pKeyInfo = pC->pKeyInfo;
                    r.nField = (u16)pOp->p4.i;
                    if (pOp->p5)
                    {
                        r.flags = UNPACKED_INCRKEY | UNPACKED_PREFIX_MATCH;
                    }
                    else
                    {
                        r.flags = UNPACKED_PREFIX_MATCH;
                    }
                    r.aMem = &aMem[pOp->p3];
                    rc = sqlite3VdbeIdxKeyCompare(pC, &r, &res);
                    if (pOp->opcode == OP_IdxLT)
                    {
                        res = -res;
                    }
                    else
                    {
                        res++;
                    }
                    if (res > 0)
                    {
                        pc = pOp->p2 - 1 ;
                    }
                }
                break;
            }
```



# J && K

# L

## Last

操作码为:

```c
Last P1 P2 * * *
```
(调用完此条指令),下一次使用Rowid/Column/下一跳指令,P1游标将指向数据库表/游标的最后一条记录. 如果表/索引为空,并且P2>0,那么立刻跳转到P2指令处运行.如果P2为0,而且表/索引不为空,跳转到下一条指令.
```c
            /* Opcode: Last P1 P2 * * *
            **
            ** The next use of the Rowid or Column or Next instruction for P1
            ** will refer to the last entry in the database table or index.
            ** If the table or index is empty and P2>0, then jump immediately to P2.
            ** If P2 is 0 or if the table or index is not empty, fall through
            ** to the following instruction.
            ** 下一次使用Rowid/Column/下一跳指令,P1游标将指向数据库表/游标的最后一条记录.
            ** 如果表/索引为空,并且P2>0,那么立刻跳转到P2指令处运行.
            ** 如果P2为0,而且表/索引不为空,跳转到下一条指令.
            */
            case OP_Last:          /* jump */
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                int res;

                pC = p->apCsr[pOp->p1]; /* 获得P1游标 */
                pCrsr = pC->pCursor;
                res = 0;
                if (ALWAYS(pCrsr != 0))
                {
                    rc = sqlite3BtreeLast(pCrsr, &res); /* 定位到最后一条记录 */
                }
                pC->nullRow = (u8)res;
                pC->deferredMoveto = 0;
                pC->rowidIsValid = 0;
                pC->cacheStatus = CACHE_STALE;
                if (pOp->p2 > 0 && res) /* 如果表/索引为空,并且P2>0,那么立刻跳转到P2指令处运行 */
                {
                    pc = pOp->p2 - 1;
                }
                break;
            }
```


# M

## Move

操作码格式为:

```c
Move P1 P2 P3 * *
```

将寄存器P1 ... P1+P3-1的值移动到寄存器P2 ... P2+P3+1 之中,寄存器P1 ... P1+P1-1 中的值移动之后,为Null.如果寄存器P1 ... P1+P3-1 以及 P2 ... P2+P3-1重叠,那是一个错误.

```c
            /* Opcode: Move P1 P2 P3 * *
            **
            ** Move the values in register P1..P1+P3-1 over into
            ** registers P2..P2+P3-1.  Registers P1..P1+P1-1 are
            ** left holding a NULL.  It is an error for register ranges
            ** P1..P1+P3-1 and P2..P2+P3-1 to overlap.
            */
            case OP_Move:
            {
                char *zMalloc;   /* Holding variable for allocated memory */
                int n;           /* Number of registers left to copy */
                int p1;          /* Register to copy from */
                int p2;          /* Register to copy to */

                n = pOp->p3;
                p1 = pOp->p1;
                p2 = pOp->p2;

                pIn1 = &aMem[p1]; /* 源 */
                pOut = &aMem[p2]; /* 目的 */
                while (n--)
                {
                    memAboutToChange(p, pOut);
                    zMalloc = pOut->zMalloc;
                    pOut->zMalloc = 0;
                    sqlite3VdbeMemMove(pOut, pIn1); /* 值转移 */
                    pIn1->zMalloc = zMalloc;
                    REGISTER_TRACE(p2++, pOut);
                    pIn1++;
                    pOut++;
                }
                break;
            }
```
## MakeRecord

操作码为:

```c
MakeRecord P1 P2 P3 P4 *
```

将以P1指示的寄存器开始,P2个的值转换为record, record将用作数据或者索引的key,OP_Column操作码可以稍后解码记录.结果放入P3寄存器.

P4可能是一个长度为P2个字符的字符串.

```c
            /* Opcode: MakeRecord P1 P2 P3 P4 *
            **
            ** Convert P2 registers beginning with P1 into the [record format]
            ** use as a data record in a database table or as a key
            ** in an index.  The OP_Column opcode can decode the record later.
            ** 将以P1指示的寄存器开始,P2个的值转换为record, record将用作数据或者索引的key,OP_Column操作码
            ** 可以稍后解码记录.结果放入P3寄存器.
            **
            ** P4 may be a string that is P2 characters long.  The nth character of the
            ** string indicates the column affinity that should be used for the nth
            ** field of the index key.
            ** P4可能是一个长度为P2个字符的字符串.
            **
            ** The mapping from character to affinity is given by the SQLITE_AFF_
            ** macros defined in sqliteInt.h.
            **
            ** If P4 is NULL then all index fields have the affinity NONE.
            */
            case OP_MakeRecord:
            {
                /* 记录新的record */
                u8 *zNewRecord;        /* A buffer to hold the data for the new record */
                Mem *pRec;             /* The new record */
                u64 nData;             /* Number of bytes of data space */
                int nHdr;              /* Number of bytes of header space */
                i64 nByte;             /* Data space required for this record */
                int nZero;             /* Number of zero bytes at the end of the record */
                int nVarint;           /* Number of bytes in a varint */
                /* 序列化之后的类型 */
                u32 serial_type;       /* Type field */
                Mem *pData0;           /* First field to be combined into the record */
                Mem *pLast;            /* Last field of the record */
                int nField;            /* Number of fields in the record */
                char *zAffinity;       /* The affinity string for the record */
                int file_format;       /* File format to use for encoding */
                int i;                 /* Space used in zNewRecord[] */
                int len;               /* Length of a field */

                /* Assuming the record contains N fields, the record format looks
                ** like this:
                ** 假定record包含N个字段, record的格式如下:
                **
                ** ------------------------------------------------------------------------
                ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 |
                ** ------------------------------------------------------------------------
                **
                ** Data(0) is taken from register P1.  Data(1) comes from register P1+1
                ** and so froth.
                ** Data(0)从寄存器P1中取, Data(1)从寄存器P1+1中取...
                **
                ** Each type field is a varint representing the serial type of the
                ** corresponding data element (see sqlite3VdbeSerialType()). The
                ** hdr-size field is also a varint which is the offset from the beginning
                ** of the record to data0.
                ** 每一个类型字段都是一个varint,hdr-size也是一个varint,记录着data0的偏移
                */
                nData = 0;         /* Number of bytes of data space */
                nHdr = 0;          /* Number of bytes of header space */
                nZero = 0;         /* Number of zero bytes at the end of the record */
                nField = pOp->p1; /* 字段的个数 */
                zAffinity = pOp->p4.z;
                pData0 = &aMem[nField]; /* 指向data(0) */
                nField = pOp->p2; /* 字段个数 */
                pLast = &pData0[nField - 1]; /* 最后一个data */
                file_format = p->minWriteFileFormat;

                /* Identify the output register */
                assert(pOp->p3 < pOp->p1 || pOp->p3 >= pOp->p1 + pOp->p2);
                pOut = &aMem[pOp->p3];
                memAboutToChange(p, pOut);

                /* Loop through the elements that will make up the record to figure
                ** out how much space is required for the new record.
                ** 计算消耗的空间
                */
                for (pRec = pData0; pRec <= pLast; pRec++)
                {
                    assert(memIsValid(pRec));
                    if (zAffinity)
                    {
                        applyAffinity(pRec, zAffinity[pRec - pData0], encoding);
                    }
                    if (pRec->flags & MEM_Zero && pRec->n > 0)
                    {
                        sqlite3VdbeMemExpandBlob(pRec);
                    }
                    serial_type = sqlite3VdbeSerialType(pRec, file_format); /* 序列化之后的类型值 */
                    len = sqlite3VdbeSerialTypeLen(serial_type); /* 长度 */
                    nData += len; /* 获取长度 */
                    nHdr += sqlite3VarintLen(serial_type);
                    if (pRec->flags & MEM_Zero)
                    {
                        /* Only pure zero-filled BLOBs can be input to this Opcode.
                        ** We do not allow blobs with a prefix and a zero-filled tail. */
                        nZero += pRec->u.nZero;
                    }
                    else if (len)
                    {
                        nZero = 0;
                    }
                }

                /* Add the initial header varint and total the size */
                nHdr += nVarint = sqlite3VarintLen(nHdr);
                if (nVarint < sqlite3VarintLen(nHdr))
                {
                    nHdr++;
                }
                nByte = nHdr + nData - nZero;
                if (nByte > db->aLimit[SQLITE_LIMIT_LENGTH])
                {
                    goto too_big;
                }

                /* Make sure the output register has a buffer large enough to store
                ** the new record. The output register (pOp->p3) is not allowed to
                ** be one of the input registers (because the following call to
                ** sqlite3VdbeMemGrow() could clobber the value before it is used).
                */
                if (sqlite3VdbeMemGrow(pOut, (int)nByte, 0))
                {
                    goto no_mem;
                }
                zNewRecord = (u8 *)pOut->z;

                /* Write the record */
                i = putVarint32(zNewRecord, nHdr);
                for (pRec = pData0; pRec <= pLast; pRec++) /* 将数据写入 */
                {
                    serial_type = sqlite3VdbeSerialType(pRec, file_format);
                    i += putVarint32(&zNewRecord[i], serial_type);      /* serial type */
                }
                for (pRec = pData0; pRec <= pLast; pRec++) /* serial data */
                {
                    i += sqlite3VdbeSerialPut(&zNewRecord[i], (int)(nByte - i), pRec, file_format);
                }
                pOut->n = (int)nByte;
                pOut->flags = MEM_Blob | MEM_Dyn; /* 内存动态分配 */
                pOut->xDel = 0;
                if (nZero)
                {
                    pOut->u.nZero = nZero;
                    pOut->flags |= MEM_Zero;
                }
                pOut->enc = SQLITE_UTF8;  /* In case the blob is ever converted to text */
                UPDATE_MAX_BLOBSIZE(pOut);
                break;
            }
```


# N

## Null

```c
Opcode: Null * P2 P3 * *
```

将Null写入寄存器P2,如果P3比P2要大,同时将Null写入P3,以及P2~P3之间的寄存器.如果P3小于P2(通常P3为0),那么只有P2寄存器被设置为NULL.

```c
			// pOut为 Mem数组.
			case OP_Null:             /* out2-prerelease */
            {
                int cnt;
                cnt = pOp->p3 - pOp->p2;
                assert(pOp->p3 <= p->nMem);
                pOut->flags = MEM_Null;
                while (cnt > 0)
                {
                    pOut++;
                    memAboutToChange(p, pOut);
                    VdbeMemRelease(pOut); /* 释放内存,将值设置为Null */
                    pOut->flags = MEM_Null;
                    cnt--;
                }
                break;
            }
```
## NullRow

操作码为:

```c
NullRow P1 * * * *
```

将游标P1移动到一个空行(null row).当游标在一个空行上时执行Column,将会导致写入一个NULL.

```c
            /* Opcode: NullRow P1 * * * *
            **
            ** Move the cursor P1 to a null row.  Any OP_Column operations
            ** that occur while the cursor is on the null row will always
            ** write a NULL.
            ** 将游标P1移动到一个空行(null row).当游标在一个空行上时执行Column,将会导致写入
            ** 一个NULL.
            */
            case OP_NullRow:
            {
                VdbeCursor *pC;

                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);
                pC = p->apCsr[pOp->p1];
                assert(pC != 0);
                pC->nullRow = 1;
                pC->rowidIsValid = 0;
                assert(pC->pCursor || pC->pVtabCursor);
                if (pC->pCursor)
                {
                    sqlite3BtreeClearCursor(pC->pCursor);
                }
                break;
            }
```
## Next && Prev

Next操作码为:

```c
Next P1 P2 * P4 P5
```

移动游标P1,让其指向一下一个key/data对,如果游标到了最后的位置,跳转到下一条指令,否则跳转到指令P2处继续执行.

游标P1必须指向一个真表,而不是一个伪表.

P4的类型为ADVANCE(指针类型),这个函数指针指向sqlite3BtreeNext().

如果P5为正数,并且跳转发生了,那么在prepared statement中的事件计数器P5-1会递增.

Prev的操作码为:

```c
Prev P1 P2 * * P5
```

向前移动游标P1,让它指向对应表/索引的前一个key/data对.如果已经没有了更多的key/data对那么跳转到下一跳指令,但是如果游标移动成功,跳转到指令P2处继续执行.

P4的类型为ADVANCE,这个函数指针指向sqlite3BtreePrevious().

如果P5为正数,并且跳转发生了,那么在prepared statement中的事件计数器P5-1会递增.

```c

            /* Opcode: Next P1 P2 * P4 P5
            **
            ** Advance cursor P1 so that it points to the next key/data pair in its
            ** table or index.  If there are no more key/value pairs then fall through
            ** to the following instruction.  But if the cursor advance was successful,
            ** jump immediately to P2.
            ** 移动游标P1,让其指向一下一个key/data对,如果游标到了最后的位置,跳转到下一条指令,
            ** 否则跳转到指令P2处继续执行
            **
            ** The P1 cursor must be for a real table, not a pseudo-table.
            ** 游标P1必须指向一个真表,而不是一个伪表.
            **
            ** P4 is always of type P4_ADVANCE. The function pointer points to
            ** sqlite3BtreeNext().
            ** P4的类型为ADVANCE,这个函数指针指向sqlite3BtreeNext()
            **
            ** If P5 is positive and the jump is taken, then event counter
            ** number P5-1 in the prepared statement is incremented.
            ** 如果P5为正数,并且跳转发生了,那么在prepared statement中的事件计数器P5-1会递增.
            **
            ** See also: Prev
            */
            /* Opcode: Prev P1 P2 * * P5
            **
            ** Back up cursor P1 so that it points to the previous key/data pair in its
            ** table or index.  If there is no previous key/value pairs then fall through
            ** to the following instruction.  But if the cursor backup was successful,
            ** jump immediately to P2.
            ** 向前移动游标P1,让它指向对应表/索引的前一个key/data对.如果已经没有了更多的key/data对
            ** 那么跳转到下一跳指令,但是如果游标移动成功,跳转到指令P2处继续执行.
            **
            ** The P1 cursor must be for a real table, not a pseudo-table.
            **
            ** P4 is always of type P4_ADVANCE. The function pointer points to
            ** sqlite3BtreePrevious().
            ** P4的类型为ADVANCE,这个函数指针指向sqlite3BtreePrevious()
            **
            ** If P5 is positive and the jump is taken, then event counter
            ** number P5-1 in the prepared statement is incremented.
            ** 如果P5为正数,并且跳转发生了,那么在prepared statement中的事件计数器P5-1会递增.
            */
            case OP_SorterNext:    /* jump */
            case OP_Prev:          /* jump */
            case OP_Next:          /* jump */
            {
                VdbeCursor *pC;
                int res;

                CHECK_FOR_INTERRUPT;
                pC = p->apCsr[pOp->p1];
                if (pC == 0)
                {
                    break;  /* See ticket #2273 */
                }
                if (isSorter(pC))
                {
                    rc = sqlite3VdbeSorterNext(db, pC, &res);
                }
                else
                {
                    res = 1;
                    rc = pOp->p4.xAdvance(pC->pCursor, &res);
                }
                pC->nullRow = (u8)res;
                pC->cacheStatus = CACHE_STALE;
                if (res == 0) /* 游标已经到达了边界 */
                {
                    pc = pOp->p2 - 1;
                    if (pOp->p5) p->aCounter[pOp->p5 - 1]++; /* 计数器+1 */
                }
                pC->rowidIsValid = 0;
                break;
            }

```
## NewRowid

操作码为:

```c
NewRowid P1 P2 P3 * *
```

获得一个新的整数类型的record number,将其作为一张表的一个key,record number在数据库表(由P1游标指向)中应该从未被使用过. 新的record number将会写入寄存器P2.如果P3>0,那么P3是VDBE root frame中的一个寄存器,它记录了先前生成的最大的record number.新生成的record number要大于这个值.P3的值帮助实现AUTOINCREMENT特性.

```c
            /* Opcode: NewRowid P1 P2 P3 * *
            **
            ** Get a new integer record number (a.k.a "rowid") used as the key to a table.
            ** The record number is not previously used as a key in the database
            ** table that cursor P1 points to.  The new record number is written
            ** written to register P2.
            ** 获得一个新的整数类型的record number,将其作为一张表的一个key,
            ** record number在数据库表(由P1游标指向)中应该从未被使用过.
            ** 新的record number将会写入寄存器P2
            **
            ** If P3>0 then P3 is a register in the root frame of this VDBE that holds
            ** the largest previously generated record number. No new record numbers are
            ** allowed to be less than this value. When this value reaches its maximum,
            ** an SQLITE_FULL error is generated. The P3 register is updated with the '
            ** generated record number. This P3 mechanism is used to help implement the
            ** AUTOINCREMENT feature.
            ** 如果P3>0,那么P3是VDBE root frame中的一个寄存器,它记录了先前生成的最大的record number.
            ** 新生成的record number要大于这个值.P3的值帮助实现AUTOINCREMENT特性.
            */
            case OP_NewRowid:             /* out2-prerelease */
            {
                /* 新的rowid */
                i64 v;                 /* The new rowid */
                VdbeCursor *pC;        /* Cursor of table to get the new rowid */
                int res;               /* Result of an sqlite3BtreeLast() */
                int cnt;               /* Counter to limit the number of searches */
                Mem *pMem;             /* Register holding largest rowid for AUTOINCREMENT */
                VdbeFrame *pFrame;     /* Root frame of VDBE */

                v = 0;
                res = 0;
                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);
                pC = p->apCsr[pOp->p1];
                assert(pC != 0);
                if (NEVER(pC->pCursor == 0))
                {
                    /* The zero initialization above is all that is needed */
                }
                else
                {
                    /* The next rowid or record number (different terms for the same
                    ** thing) is obtained in a two-step algorithm.
                    **
                    ** First we attempt to find the largest existing rowid and add one
                    ** to that.  But if the largest existing rowid is already the maximum
                    ** positive integer, we have to fall through to the second
                    ** probabilistic algorithm
                    **
                    ** The second algorithm is to select a rowid at random and see if
                    ** it already exists in the table.  If it does not exist, we have
                    ** succeeded.  If the random rowid does exist, we select a new one
                    ** and try again, up to 100 times.
                    */
                    assert(pC->isTable);

#ifdef SQLITE_32BIT_ROWID
#   define MAX_ROWID 0x7fffffff
#else
                    /* Some compilers complain about constants of the form 0x7fffffffffffffff.
                    ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems
                    ** to provide the constant while making all compilers happy.
                    */
#   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
#endif

                    if (!pC->useRandomRowid)
                    {
                        v = sqlite3BtreeGetCachedRowid(pC->pCursor);
                        if (v == 0)
                        {
                            /* 将游标移动到最后一个entry */
                            rc = sqlite3BtreeLast(pC->pCursor, &res);
                            if (rc != SQLITE_OK)
                            {
                                goto abort_due_to_error;
                            }
                            if (res)
                            {
                                v = 1;   /* IMP: R-61914-48074 */
                            }
                            else
                            {
                                assert(sqlite3BtreeCursorIsValid(pC->pCursor));
                                rc = sqlite3BtreeKeySize(pC->pCursor, &v);
                                assert(rc == SQLITE_OK);   /* Cannot fail following BtreeLast() */
                                if (v >= MAX_ROWID) /* 过大,就回转 */
                                {
                                    pC->useRandomRowid = 1;
                                }
                                else /* 直接递增即可 */
                                {
                                    v++;   /* IMP: R-29538-34987 */
                                }
                            }
                        }
#ifndef SQLITE_OMIT_AUTOINCREMENT
                        if (pOp->p3)
                        {
                            if (p->pFrame)
                            {
                                for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent);
                                pMem = &pFrame->aMem[pOp->p3];
                            }
                            else
                            {
                                /* Assert that P3 is a valid memory cell. */
                                assert(pOp->p3 <= p->nMem);
                                pMem = &aMem[pOp->p3];
                                memAboutToChange(p, pMem);
                            }
                            REGISTER_TRACE(pOp->p3, pMem);
                            sqlite3VdbeMemIntegerify(pMem);
                            if (pMem->u.i == MAX_ROWID || pC->useRandomRowid)
                            {
                                rc = SQLITE_FULL;   /* IMP: R-12275-61338 */
                                goto abort_due_to_error;
                            }
                            if (v < pMem->u.i + 1)
                            {
                                v = pMem->u.i + 1;
                            }
                            pMem->u.i = v;
                        }
#endif
                        sqlite3BtreeSetCachedRowid(pC->pCursor, v < MAX_ROWID ? v + 1 : 0);
                    }
                    if (pC->useRandomRowid)
                    {
                        /* IMPLEMENTATION-OF: R-07677-41881 If the largest ROWID is equal to the
                        ** largest possible integer (9223372036854775807) then the database
                        ** engine starts picking positive candidate ROWIDs at random until
                        ** it finds one that is not previously used. */
                        /* on the first attempt, simply do one more than previous */
                        v = lastRowid;
                        v &= (MAX_ROWID >> 1); /* ensure doesn't go negative */
                        v++; /* ensure non-zero */
                        cnt = 0;
                        while (((rc = sqlite3BtreeMovetoUnpacked(pC->pCursor, 0, (u64)v,
                                      0, &res)) == SQLITE_OK)
                               && (res == 0)
                               && (++cnt < 100))
                        {
                            /* collision - try another random rowid */
                            sqlite3_randomness(sizeof(v), &v);
                            if (cnt < 5)
                            {
                                /* try "small" random rowids for the initial attempts */
                                v &= 0xffffff;
                            }
                            else
                            {
                                v &= (MAX_ROWID >> 1); /* ensure doesn't go negative */
                            }
                            v++; /* ensure non-zero */
                        }
                        if (rc == SQLITE_OK && res == 0)
                        {
                            rc = SQLITE_FULL;   /* IMP: R-38219-53002 */
                            goto abort_due_to_error;
                        }
                        assert(v > 0);  /* EV: R-40812-03570 */
                    }
                    pC->rowidIsValid = 0;
                    pC->deferredMoveto = 0;
                    pC->cacheStatus = CACHE_STALE;
                }
                pOut->u.i = v;
                break;
            }
```

## NotExists

操作码为:

```c
NotExists P1 P2 P3 * *
```

将寄存器P3中的值作为一个整数key,如果通过这个key在P1表中找不到记录,跳转到指令P2处执行,记录存在,继续执行下一条指令.

```c
            /* Opcode: NotExists P1 P2 P3 * *
            **
            ** Use the content of register P3 as an integer key.  If a record
            ** with that key does not exist in table of P1, then jump to P2.
            ** If the record does exist, then fall through.  The cursor is left
            ** pointing to the record if it exists.
            ** 将寄存器P3中的值作为一个整数key,如果通过这个key在P1表中找不到记录,跳转到P2
            ** 记录存在,继续执行
            **
            ** The difference between this operation and NotFound is that this
            ** operation assumes the key is an integer and that P1 is a table whereas
            ** NotFound assumes key is a blob constructed from MakeRecord and
            ** P1 is an index.
            **
            ** See also: Found, NotFound, IsUnique
            */
            case OP_NotExists:          /* jump, in3 */
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                int res;
                u64 iKey;

                pIn3 = &aMem[pOp->p3];
                assert(pIn3->flags & MEM_Int);
                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);
                pC = p->apCsr[pOp->p1];
                assert(pC != 0);
                assert(pC->isTable);
                assert(pC->pseudoTableReg == 0);
                pCrsr = pC->pCursor;
                if (ALWAYS(pCrsr != 0))
                {
                    res = 0;
                    iKey = pIn3->u.i;
                    rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
                    pC->lastRowid = pIn3->u.i;
                    pC->rowidIsValid = res == 0 ? 1 : 0;
                    pC->nullRow = 0;
                    pC->cacheStatus = CACHE_STALE;
                    pC->deferredMoveto = 0;
                    if (res != 0)
                    {
                        pc = pOp->p2 - 1;
                        assert(pC->rowidIsValid == 0);
                    }
                    pC->seekResult = res;
                }
                else
                {
                    /* This happens when an attempt to open a read cursor on the
                    ** sqlite_master table returns SQLITE_EMPTY.
                    */
                    pc = pOp->p2 - 1;
                    assert(pC->rowidIsValid == 0);
                    pC->seekResult = 0;
                }
                break;
            }
```





# O

## OpenEphemeral && OpenAutoindex

OpenEphemeral的操作码为:

```c
OpenEphemeral P1 P2 * P4 P5
```

在临时表中打开一个新的游标P1,游标可读可写.游标关闭之后,表会被删掉.

P2是临时表中列的个数,如果P4为0(NULL), 游标指向一个BTree Table,否则指向BTree index.如果P4不为空,那么它指向一个KeyInfo结构体,定义了索引的key的格式.

```c
            /* Opcode: OpenEphemeral P1 P2 * P4 P5
            **
            ** Open a new cursor P1 to a transient table.
            ** The cursor is always opened read/write even if
            ** the main database is read-only.  The ephemeral
            ** table is deleted automatically when the cursor is closed.
            ** 在临时表中打开一个新的游标P1,游标可读可写.游标关闭之后,表会被删掉.
            **
            ** P2 is the number of columns in the ephemeral table.
            ** The cursor points to a BTree table if P4==0 and to a BTree index
            ** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure
            ** that defines the format of keys in the index.
            ** P2是临时表中列的个数,如果P4为0(NULL), 游标指向一个BTree Table,否则指向BTree index.
            ** 如果P4不为空,那么它指向一个KeyInfo结构体,定义了索引的key的格式.
            **
            ** This opcode was once called OpenTemp.  But that created
            ** confusion because the term "temp table", might refer either
            ** to a TEMP table at the SQL level, or to a table opened by
            ** this opcode.  Then this opcode was call OpenVirtual.  But
            ** that created confusion with the whole virtual-table idea.
            ** 这个操作码曾经被称之为OpenTemp,但是因为temp table的缘故造成了困扰....
            ** 因此改名.
            **
            ** The P5 parameter can be a mask of the BTREE_* flags defined
            ** in btree.h.  These flags control aspects of the operation of
            ** the btree.  The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are
            ** added automatically.
            ** 参数P5是标记BTREE_*的掩码,这些标记控制着打开btree的操作.
            */
            /* Opcode: OpenAutoindex P1 P2 * P4 *
            **
            ** This opcode works the same as OP_OpenEphemeral.  It has a
            ** different name to distinguish its use.  Tables created using
            ** by this opcode will be used for automatically created transient
            ** indices in joins.
            ** 此操作码和Op_OpenEphemera一样.仅仅是换了一个名称.通过此操作码创建的表将会
            ** 被用于joins中的临时索引.
            */
            case OP_OpenAutoindex:
            case OP_OpenEphemeral:
            {
                VdbeCursor *pCx;
                static const int vfsFlags =
                    SQLITE_OPEN_READWRITE |
                    SQLITE_OPEN_CREATE |
                    SQLITE_OPEN_EXCLUSIVE |
                    SQLITE_OPEN_DELETEONCLOSE |
                    SQLITE_OPEN_TRANSIENT_DB;

                pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, 1); /* 分配新游标 */
                if (pCx == 0) goto no_mem;
                pCx->nullRow = 1;
                rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBt,
                                      BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5, vfsFlags);
                if (rc == SQLITE_OK)
                {
                    rc = sqlite3BtreeBeginTrans(pCx->pBt, 1); /* 开启事务 */
                }
                if (rc == SQLITE_OK)
                {
                    /* If a transient index is required, create it by calling
                    ** sqlite3BtreeCreateTable() with the BTREE_BLOBKEY flag before
                    ** opening it. If a transient table is required, just use the
                    ** automatically created table with root-page 1 (an BLOB_INTKEY table).
                    ** 如果需要一个临时的索引,通过调用sqlite3BtreeCreateTable()来创建.
                    ** 如果临时的表被需要..
                    */
                    if (pOp->p4.pKeyInfo)
                    {
                        int pgno;
                        /* 这里会创建一个临时表(索引) */
                        rc = sqlite3BtreeCreateTable(pCx->pBt, &pgno, BTREE_BLOBKEY | pOp->p5);
                        if (rc == SQLITE_OK)
                        {
                            /* 打开索引 */
                            rc = sqlite3BtreeCursor(pCx->pBt, pgno, 1,
                                                    (KeyInfo*)pOp->p4.z, pCx->pCursor);
                            pCx->pKeyInfo = pOp->p4.pKeyInfo;
                            pCx->pKeyInfo->enc = ENC(p->db);
                        }
                        pCx->isTable = 0;
                    }
                    else
                    {
                        rc = sqlite3BtreeCursor(pCx->pBt, MASTER_ROOT, 1, 0, pCx->pCursor);
                        pCx->isTable = 1;
                    }
                }
                pCx->isOrdered = (pOp->p5 != BTREE_UNORDERED);
                pCx->isIndex = !pCx->isTable;
                break;
            }
```

## Once

操作码为:

```c
Once P1 P2 * * *
```

检查一下标记P1是否被设定,如果设定了,跳转到指令P2处执行,否则的话,设置flag,继续执行下一条指令.

```c
            /* Opcode: Once P1 P2 * * *
            **
            ** Check if OP_Once flag P1 is set. If so, jump to instruction P2. Otherwise,
            ** set the flag and fall through to the next instruction.
            ** 检查一下标记P1是否被设定,如果设定了,跳转到指令P2处执行,否则的话,设置flag,继续执行下一条指令.
            **
            ** See also: JumpOnce
            */
            case OP_Once:               /* jump */
            {
                assert(pOp->p1 < p->nOnceFlag);
                if (p->aOnceFlag[pOp->p1])
                {
                    pc = pOp->p2 - 1;
                }
                else
                {
                    p->aOnceFlag[pOp->p1] = 1; /* 设置once标记 */
                }
                break;
            }
```

## OpenRead && OpenWrite

OpenRead的操作码为:

```c
OpenRead P1 P2 P3 P4 P5
```

为数据库的表打开一个只读的游标,表在数据库文件中的root page为P2,数据库文件通过P3来确定,如果P3为0,表示主数据库,P3为1的话,表示临时表的数据库,P3>1的话,表示attach的数据库.

如果P5不为0,那么使用寄存器P2中的值作为root page,而不是P2的值.

P4的值要么是一个整数,要么是一个指向KeyInfo结构体的指针,如果它是一个指针的话,指向的结构定义了内容和索引内容的排序.如果是整数,它设置为表中的列数.

OpenWrite的操作码为:

```sql
OpenWrite P1 P2 P3 P4 P5
```

在表/索引上打开一个读/写游标(名字为P1),表/索引的root page为P2, 如果P5!=0,那么用P2寄存器中的值来查找root page.
P3寄存器的值用于指定数据库.

P4的值要么是一个整数(P4_INT32), 要么是一个指向KeyInfo结构体的指针(P4_KEYINFO),如果P4是指向keyInfo结构体的指针,那么说明这个结构体定义了内用以及打开的索引的collating sequence,否则的话,P4是一个整数值,它表示表的列数,或者设置为实际使用的表的任何列的最大索引

```c
            /* Opcode: OpenRead P1 P2 P3 P4 P5
            **
            ** Open a read-only cursor for the database table whose root page is
            ** P2 in a database file.  The database file is determined by P3.
            ** P3==0 means the main database, P3==1 means the database used for
            ** temporary tables, and P3>1 means used the corresponding attached
            ** database.  Give the new cursor an identifier of P1.  The P1
            ** values need not be contiguous but all P1 values should be small integers.
            ** It is an error for P1 to be negative.
            ** 为数据库的表打开一个只读的游标,表在数据库文件中的root page为P2,数据库文件通过P3
            ** 来确定,如果P3为0,表示主数据库,P3为1的话,表示临时表的数据库,P3>1的话,表示attach的数据库.
            **
            ** If P5!=0 then use the content of register P2 as the root page, not
            ** the value of P2 itself.
            ** 如果P5不为0,那么使用寄存器P2中的值作为root page,而不是P2的值.
            **
            ** There will be a read lock on the database whenever there is an
            ** open cursor.  If the database was unlocked prior to this instruction
            ** then a read lock is acquired as part of this instruction.  A read
            ** lock allows other processes to read the database but prohibits
            ** any other process from modifying the database.  The read lock is
            ** released when all cursors are closed.  If this instruction attempts
            ** to get a read lock but fails, the script terminates with an
            ** SQLITE_BUSY error code.
            ** 打开游标的时候,数据库将会加一个读锁.如果在这条指令之前数据库已经解锁,那么这条指令
            ** 会加一个读锁.读锁允许其他进程来读取数据库内容,禁止其他进程修改.所有游标关闭之后,
            ** 读锁才会被释放.如果获取读锁失败,那么script终止,返回一个SQLITE_BUSY的错误码.
            **
            ** The P4 value may be either an integer (P4_INT32) or a pointer to
            ** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo
            ** structure, then said structure defines the content and collating
            ** sequence of the index being opened. Otherwise, if P4 is an integer
            ** value, it is set to the number of columns in the table.
            ** P4的值要么是一个整数,要么是一个指向KeyInfo结构体的指针,如果它是一个指针的话,指向的
            ** 结构定义了内容和索引内容的排序.如果是整数,它设置为表中的列数.
            **
            ** See also OpenWrite.
            */
            /* Opcode: OpenWrite P1 P2 P3 P4 P5
            **
            ** Open a read/write cursor named P1 on the table or index whose root
            ** page is P2.  Or if P5!=0 use the content of register P2 to find the
            ** root page.
            ** 在表/索引上打开一个读/写游标(名字为P1),表/索引的root page为P2, 如果P5!=0,那么用P2寄存器
            ** 中的值来查找root page.
            ** P3寄存器的值用于指定数据库.
            **
            ** The P4 value may be either an integer (P4_INT32) or a pointer to
            ** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo
            ** structure, then said structure defines the content and collating
            ** sequence of the index being opened. Otherwise, if P4 is an integer
            ** value, it is set to the number of columns in the table, or to the
            ** largest index of any column of the table that is actually used.
            ** P4的值要么是一个整数(P4_INT32), 要么是一个指向KeyInfo结构体的指针(P4_KEYINFO),
            ** 如果P4是指向keyInfo结构体的指针,那么说明这个结构体定义了内用以及打开的索引的collating sequence
            ** 否则的话,P4是一个整数值,它表示表的列数,或者设置为实际使用的表的任何列的最大索引
            **
            ** This instruction works just like OpenRead except that it opens the cursor
            ** in read/write mode.  For a given table, there can be one or more read-only
            ** cursors or a single read/write cursor but not both.
            **
            ** See also OpenRead.
            */
            case OP_OpenRead:
            case OP_OpenWrite:
            {
                int nField;
                KeyInfo *pKeyInfo;
                int p2;
                int iDb;
                int wrFlag;
                Btree *pX;
                VdbeCursor *pCur;
                Db *pDb;

                if (p->expired)
                {
                    rc = SQLITE_ABORT;
                    break;
                }

                nField = 0;
                pKeyInfo = 0;
                p2 = pOp->p2;
                iDb = pOp->p3; /* 参数P3用于指定数据库 */
                assert(iDb >= 0 && iDb < db->nDb);
                assert((p->btreeMask & (((yDbMask)1) << iDb)) != 0);
                pDb = &db->aDb[iDb];
                pX = pDb->pBt;
                assert(pX != 0);
                if (pOp->opcode == OP_OpenWrite) /* 写游标 */
                {
                    wrFlag = 1;
                    assert(sqlite3SchemaMutexHeld(db, iDb, 0));
                    if (pDb->pSchema->file_format < p->minWriteFileFormat)
                    {
                        p->minWriteFileFormat = pDb->pSchema->file_format;
                    }
                }
                else
                {
                    wrFlag = 0;
                }
                if (pOp->p5 & OPFLAG_P2ISREG)
                {
                    pIn2 = &aMem[p2]; /* 获取P2寄存器的值 */
                    sqlite3VdbeMemIntegerify(pIn2);
                    p2 = (int)pIn2->u.i;
                    /* The p2 value always comes from a prior OP_CreateTable opcode and
                    ** that opcode will always set the p2 value to 2 or more or else fail.
                    ** If there were a failure, the prepared statement would have halted
                    ** before reaching this instruction. */
                    if (NEVER(p2 < 2))
                    {
                        rc = SQLITE_CORRUPT_BKPT;
                        goto abort_due_to_error;
                    }
                }
                if (pOp->p4type == P4_KEYINFO)
                {
                    pKeyInfo = pOp->p4.pKeyInfo; /* p4指向一个keyInfo */
                    pKeyInfo->enc = ENC(p->db);
                    nField = pKeyInfo->nField + 1;
                }
                else if (pOp->p4type == P4_INT32)
                {
                    nField = pOp->p4.i; /* 列数 */
                }
                pCur = allocateCursor(p, pOp->p1, nField, iDb, 1);
                if (pCur == 0) goto no_mem;
                pCur->nullRow = 1;
                pCur->isOrdered = 1;
                /* 创建一个游标,p2是root page的页号 */
                rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->pCursor);
                pCur->pKeyInfo = pKeyInfo;
                sqlite3BtreeCursorHints(pCur->pCursor, (pOp->p5 & OPFLAG_BULKCSR));

                /* Set the VdbeCursor.isTable and isIndex variables. Previous versions of
                ** SQLite used to check if the root-page flags were sane at this point
                ** and report database corruption if they were not, but this check has
                ** since moved into the btree layer.  */
                pCur->isTable = pOp->p4type != P4_KEYINFO;
                pCur->isIndex = !pCur->isTable;
                break;
            }
```



# P && Q


# R
## Rewind

操作码为:

```c
 Rewind P1 P2 * * *
```

下一次使用Rowid或者操作游标P1的下一条指令将会指向数据库表/索引的第一条记录.如果表/索引为空,P2>0,那么立即跳转到指令P2出运行,如果P2为0,或者表/索引不为空继续执行下一条指令.

```c
            /* Opcode: Rewind P1 P2 * * *
            **
            ** The next use of the Rowid or Column or Next instruction for P1
            ** will refer to the first entry in the database table or index.
            ** If the table or index is empty and P2>0, then jump immediately to P2.
            ** If P2 is 0 or if the table or index is not empty, fall through
            ** to the following instruction.
            ** 下一次使用Rowid或者操作游标P1的下一条指令将会指向数据库表/索引的第一条记录.
            ** 如果表/索引为空,P2>0,那么立即跳转到指令P2出运行,如果P2为0,或者表/索引不为空
            ** 继续执行下一条指令.
            */
            case OP_Rewind:          /* jump */
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                int res;

                pC = p->apCsr[pOp->p1];
                res = 1;
                if (isSorter(pC))
                {
                    rc = sqlite3VdbeSorterRewind(db, pC, &res);
                }
                else
                {
                    pCrsr = pC->pCursor;
                    rc = sqlite3BtreeFirst(pCrsr, &res); /* 移动到第一条记录 */
                    pC->atFirst = res == 0 ? 1 : 0;
                    pC->deferredMoveto = 0;
                    pC->cacheStatus = CACHE_STALE;
                    pC->rowidIsValid = 0;
                }
                pC->nullRow = (u8)res;
                if (res)
                {
                    pc = pOp->p2 - 1;
                }
                break;
            }
```

## Return

操作码为:

```c
Return P1 * * * *
```

跳转到p1指向地址的下一条指令继续运行.

```c
            /* Opcode:  Return P1 * * * *
            **
            ** Jump to the next instruction after the address in register P1.
            ** 跳转到p1指向地址的下一条指令继续运行
            */
            case OP_Return:             /* in1 */
            {
                pIn1 = &aMem[pOp->p1];
                pc = (int)pIn1->u.i;
                break;
            }
```
## Rowid

操作码为:

```c
Rowid P1 P2 * * *
```

将游标P1当前指向的表的记录的key(整型)写入到寄存器P2.

```c
            /* Opcode: Rowid P1 P2 * * *
            **
            ** Store in register P2 an integer which is the key of the table entry that
            ** P1 is currently point to.
            ** 将游标P1当前指向的表的记录的key(整型)写入到寄存器P2.
            **
            ** P1 can be either an ordinary table or a virtual table.  There used to
            ** be a separate OP_VRowid opcode for use with virtual tables, but this
            ** one opcode now works for both table types.
            ** 游标P1可以指向一个普通的表,也可以是一个虚拟表,对于虚拟表,这里通常会有一个VRowid操作码
            ** 但是这个操作码也适用.
            */
            case OP_Rowid:                   /* out2-prerelease */
            {
                VdbeCursor *pC;
                i64 v;
                sqlite3_vtab *pVtab;
                const sqlite3_module *pModule;

                pC = p->apCsr[pOp->p1];
                if (pC->nullRow)
                {
                    pOut->flags = MEM_Null;
                    break;
                }
                else if (pC->deferredMoveto)
                {
                    v = pC->movetoTarget;
#ifndef SQLITE_OMIT_VIRTUALTABLE
                }
                else if (pC->pVtabCursor)
                {
                    pVtab = pC->pVtabCursor->pVtab;
                    pModule = pVtab->pModule;
                    rc = pModule->xRowid(pC->pVtabCursor, &v);
                    importVtabErrMsg(p, pVtab);
#endif /* SQLITE_OMIT_VIRTUALTABLE */
                }
                else
                {
                    assert(pC->pCursor != 0);
                    rc = sqlite3VdbeCursorMoveto(pC);
                    if (rc) goto abort_due_to_error;
                    if (pC->rowidIsValid)
                    {
                        v = pC->lastRowid;
                    }
                    else
                    {
                        /* 如果key是整型,sqlite3BtreeKeySize执行完之后,v中存储的就是key */
                        rc = sqlite3BtreeKeySize(pC->pCursor, &v); 
                    }
                }
                pOut->u.i = v;
                break;
            }
```

## RowKey && RowData

RowData操作码为:

```c
RowData P1 P2 * * *
```

将游标P1指向的完整的行数据写入寄存器P2,没有对数据进行解码.它只是被完全拷贝至P2寄存器,就像它从数据库文件中被找到一样.

RowKey的操作码为:

```c
RowKey P1 P2 * * *
```

和RowData类似,不过拷贝的是key的数据.

```c
            /* Opcode: RowData P1 P2 * * *
            **
            ** Write into register P2 the complete row data for cursor P1.
            ** There is no interpretation of the data.
            ** It is just copied onto the P2 register exactly as
            ** it is found in the database file.
            ** 将游标P1指向的完整的行数据写入寄存器P2,没有对数据进行解码.它只是被完全拷贝至P2
            ** 寄存器,就像它从数据库文件中被找到一样.
            **
            ** If the P1 cursor must be pointing to a valid row (not a NULL row)
            ** of a real table, not a pseudo-table.
            */
            /* Opcode: RowKey P1 P2 * * *
            **
            ** Write into register P2 the complete row key for cursor P1.
            ** There is no interpretation of the data.
            ** The key is copied onto the P3 register exactly as
            ** it is found in the database file.
            **
            ** If the P1 cursor must be pointing to a valid row (not a NULL row)
            ** of a real table, not a pseudo-table.
            */
            case OP_RowKey:
            case OP_RowData:
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                u32 n;
                i64 n64;

                pOut = &aMem[pOp->p2];
                memAboutToChange(p, pOut);

                /* Note that RowKey and RowData are really exactly the same instruction */
                pC = p->apCsr[pOp->p1]; /* 游标P1 */
                pCrsr = pC->pCursor;

                /* The OP_RowKey and OP_RowData opcodes always follow OP_NotExists or
                ** OP_Rewind/Op_Next with no intervening instructions that might invalidate
                ** the cursor.  Hence the following sqlite3VdbeCursorMoveto() call is always
                ** a no-op and can never fail.  But we leave it in place as a safety.
                */
                rc = sqlite3VdbeCursorMoveto(pC);
                if (NEVER(rc != SQLITE_OK)) goto abort_due_to_error;

                if (pC->isIndex)
                {
                    VVA_ONLY(rc =) sqlite3BtreeKeySize(pCrsr, &n64);
                    if (n64 > db->aLimit[SQLITE_LIMIT_LENGTH])
                    {
                        goto too_big;
                    }
                    n = (u32)n64;
                }
                else
                {
                    VVA_ONLY(rc =) sqlite3BtreeDataSize(pCrsr, &n);
                    if (n > (u32)db->aLimit[SQLITE_LIMIT_LENGTH])
                    {
                        goto too_big;
                    }
                }
                if (sqlite3VdbeMemGrow(pOut, n, 0))
                {
                    goto no_mem;
                }
                pOut->n = n;
                MemSetTypeFlag(pOut, MEM_Blob); /* 数据类型为Blob */
                if (pC->isIndex)
                {
                    rc = sqlite3BtreeKey(pCrsr, 0, n, pOut->z);
                }
                else
                {
                    rc = sqlite3BtreeData(pCrsr, 0, n, pOut->z);
                }
                pOut->enc = SQLITE_UTF8;  /* In case the blob is ever cast to text */
                UPDATE_MAX_BLOBSIZE(pOut);
                break;
            }

```
## ReadCookie

操作码为:

```c
ReadCookie P1 P2 P3 * *
```

从数据库P1中读取P3中的cookie值,并且写入寄存器P2.其实读取出来的都是4个字节的整数.

P3 == 1 -> schema version [schema版本]
P3 == 2 -> database format [数据库格式]
P3 == 3 -> recommended pager cache [推荐的pager cache大小]

```c
            /* Opcode: ReadCookie P1 P2 P3 * *
            **
            ** Read cookie number P3 from database P1 and write it into register P2.
            ** P3==1 is the schema version.  P3==2 is the database format.
            ** P3==3 is the recommended pager cache size, and so forth.  P1==0 is
            ** the main database file and P1==1 is the database file used to store
            ** temporary tables.
            ** 从数据库P1中读取P3所指示的cookie值,并且写入寄存器P2,其实读取出来的都是4个字节的整数.
            ** P3 == 1 -> schema version [schema版本]
            ** P3 == 2 -> database format [数据库格式]
            ** P3 == 3 -> recommended pager cache [推荐的pager cache大小]
            **
            ** There must be a read-lock on the database (either a transaction
            ** must be started or there must be an open cursor) before
            ** executing this instruction.
            */
            case OP_ReadCookie:                 /* out2-prerelease */
            {
                int iMeta;
                int iDb;
                int iCookie;

                iDb = pOp->p1;
                iCookie = pOp->p3;
                assert(pOp->p3 < SQLITE_N_BTREE_META);
                assert(iDb >= 0 && iDb < db->nDb);
                assert(db->aDb[iDb].pBt != 0);
                assert((p->btreeMask & (((yDbMask)1) << iDb)) != 0);

                sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);
                pOut->u.i = iMeta;
                break;
            }
```

# S

## String8 && String

String8操作码为:

```c
String8 * P2 * P4 *
```

P4指向一个非空的字符串,将P4指向的字符串,放入P2指向的寄存器.

String的操作码为:

```c
String P1 P2 * P4 *
```

将P4的值,长度为P1, 存入寄存器P2.

```c
            /* Opcode: String8 * P2 * P4 *
            **
            ** P4 points to a nul terminated UTF-8 string. This opcode is transformed
            ** into an OP_String before it is executed for the first time.
            ** P4指向一个非空的字符串,将P4指向的字符串,放入P2指向的寄存器
            */
            case OP_String8:           /* same as TK_STRING, out2-prerelease */
            {
                pOp->opcode = OP_String;
                pOp->p1 = sqlite3Strlen30(pOp->p4.z);

                if (pOp->p1 > db->aLimit[SQLITE_LIMIT_LENGTH])
                {
                    goto too_big;
                }
                /* Fall through to the next case, OP_String */
            }
            /* Opcode: String P1 P2 * P4 *
            **
            ** The string value P4 of length P1 (bytes) is stored in register P2.
            ** 将P4的值,长度为P1, 存入寄存器P2,
            */
            case OP_String:            /* out2-prerelease */
            {
                pOut->flags = MEM_Str | MEM_Static | MEM_Term;
                pOut->z = pOp->p4.z;
                pOut->n = pOp->p1;
                pOut->enc = encoding;
                UPDATE_MAX_BLOBSIZE(pOut);
                break;
            }
```
## Savepoint

操作码为:

```c
Savepoint P1 * * P4 *
```

打开或者释放或者回滚一个savepoint,它的名字由参数P4指定.
P1 == 0, 打开一个savepoint.
P1 == 1, 释放一个savepoint.
P1 == 2, 回滚一个savepoint.

```c
            /* Opcode: Savepoint P1 * * P4 *
            **
            ** Open, release or rollback the savepoint named by parameter P4, depending
            ** on the value of P1. To open a new savepoint, P1==0. To release (commit) an
            ** existing savepoint, P1==1, or to rollback an existing savepoint P1==2.
            ** 打开或者释放或者回滚一个savepoint,它的名字由参数P4指定.
            ** P1==0, 打开一个savepoint
            ** P1==1, 释放一个savepoint
            ** P1==2, 回滚一个savepoint
            */
            case OP_Savepoint:
            {
                int p1;                         /* Value of P1 operand */
                char *zName;                    /* Name of savepoint */
                int nName;
                Savepoint *pNew;
                Savepoint *pSavepoint;
                Savepoint *pTmp;
                int iSavepoint;
                int ii;

                p1 = pOp->p1;
                zName = pOp->p4.z;

                if (p1 == SAVEPOINT_BEGIN)
                {
                    if (db->writeVdbeCnt > 0)
                    {
                        /* A new savepoint cannot be created if there are active write
                        ** statements (i.e. open read/write incremental blob handles).
                        */
                        sqlite3SetString(&p->zErrMsg, db, "cannot open savepoint - "
                                         "SQL statements in progress");
                        rc = SQLITE_BUSY;
                    }
                    else
                    {
                        nName = sqlite3Strlen30(zName);

                        /* Create a new savepoint structure. */
                        pNew = sqlite3DbMallocRaw(db, sizeof(Savepoint) + nName + 1);
                        if (pNew)
                        {
                            pNew->zName = (char *)&pNew[1];
                            memcpy(pNew->zName, zName, nName + 1);

                            /* If there is no open transaction, then mark this as a special
                            ** "transaction savepoint". */
                            if (db->autoCommit)
                            {
                                db->autoCommit = 0;
                                db->isTransactionSavepoint = 1;
                            }
                            else
                            {
                                db->nSavepoint++;
                            }

                            /* Link the new savepoint into the database handle's list. */
                            /* 添加至链表首部 */
                            pNew->pNext = db->pSavepoint;
                            db->pSavepoint = pNew;
                            pNew->nDeferredCons = db->nDeferredCons;
                        }
                    }
                }
                else
                {
                    iSavepoint = 0;
                    /* 首先找到对应的savepoint */
                    /* Find the named savepoint. If there is no such savepoint, then an
                    ** an error is returned to the user.  */
                    for (
                        pSavepoint = db->pSavepoint;
                        pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName);
                        pSavepoint = pSavepoint->pNext)
                    {
                        iSavepoint++; /* 统计待处理的savepoint之前还有多少个savepoint */
                    }
                    if (!pSavepoint)
                    {
                        sqlite3SetString(&p->zErrMsg, db, "no such savepoint: %s", zName);
                        rc = SQLITE_ERROR;
                    }
                    else if (db->writeVdbeCnt > 0 && p1 == SAVEPOINT_RELEASE)
                    {
                        /* It is not possible to release (commit) a savepoint if there are
                        ** active write statements.
                        */
                        sqlite3SetString(&p->zErrMsg, db,
                                         "cannot release savepoint - SQL statements in progress");
                        rc = SQLITE_BUSY;
                    }
                    else
                    {

                        /* Determine whether or not this is a transaction savepoint. If so,
                        ** and this is a RELEASE command, then the current transaction
                        ** is committed.
                        */
                        int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;
                        if (isTransaction && p1 == SAVEPOINT_RELEASE) /* 需要删除savepoint */
                        {
                            if ((rc = sqlite3VdbeCheckFk(p, 1)) != SQLITE_OK)
                            {
                                goto vdbe_return;
                            }
                            db->autoCommit = 1; /* 打上自动提交标记 */
                            if (sqlite3VdbeHalt(p) == SQLITE_BUSY)
                            {
                                p->pc = pc;
                                db->autoCommit = 0;
                                p->rc = rc = SQLITE_BUSY;
                                goto vdbe_return;
                            }
                            db->isTransactionSavepoint = 0;
                            rc = p->rc;
                        }
                        else
                        {
                            iSavepoint = db->nSavepoint - iSavepoint - 1;
                            if (p1 == SAVEPOINT_ROLLBACK) /* 需要进行回滚操作 */
                            {
                                for (ii = 0; ii < db->nDb; ii++)
                                {
                                    sqlite3BtreeTripAllCursors(db->aDb[ii].pBt, SQLITE_ABORT);
                                }
                            }
                            for (ii = 0; ii < db->nDb; ii++)
                            {
                                /* 回滚savepoint */
                                rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);
                                if (rc != SQLITE_OK)
                                {
                                    goto abort_due_to_error;
                                }
                            }
                            if (p1 == SAVEPOINT_ROLLBACK && (db->flags & SQLITE_InternChanges) != 0)
                            {
                                sqlite3ExpirePreparedStatements(db);
                                sqlite3ResetAllSchemasOfConnection(db);
                                db->flags = (db->flags | SQLITE_InternChanges);
                            }
                        }

                        /* Regardless of whether this is a RELEASE or ROLLBACK, destroy all
                        ** savepoints nested inside of the savepoint being operated on. */
                        while (db->pSavepoint != pSavepoint)
                        {
                            /* 这里其实会一直释放,直到要回滚的savepoint */
                            pTmp = db->pSavepoint;
                            db->pSavepoint = pTmp->pNext;
                            sqlite3DbFree(db, pTmp);
                            db->nSavepoint--;
                        }

                        /* If it is a RELEASE, then destroy the savepoint being operated on
                        ** too. If it is a ROLLBACK TO, then set the number of deferred
                        ** constraint violations present in the database to the value stored
                        ** when the savepoint was created.  */
                        if (p1 == SAVEPOINT_RELEASE)
                        {
                            db->pSavepoint = pSavepoint->pNext;
                            sqlite3DbFree(db, pSavepoint);
                            if (!isTransaction)
                            {
                                db->nSavepoint--;
                            }
                        }
                        else
                        {
                            db->nDeferredCons = pSavepoint->nDeferredCons;
                        }

                        if (!isTransaction)
                        {
                            rc = sqlite3VtabSavepoint(db, p1, iSavepoint);
                            if (rc != SQLITE_OK) goto abort_due_to_error;
                        }
                    }
                }
                break;
            }
```
## Seek

操作码为:

```c
Seek P1 P2 * * *
```

P1是表的游标,P2是一个rowid,使得游标移动到P2指向的记录.

```c
            /* Opcode: Seek P1 P2 * * *
            **
            ** P1 is an open table cursor and P2 is a rowid integer.  Arrange
            ** for P1 to move so that it points to the rowid given by P2.
            ** P1是表的游标,P2是一个rowid,使得游标移动到P2指向的记录
            **
            ** This is actually a deferred seek.  Nothing actually happens until
            ** the cursor is used to read a record.  That way, if no reads
            ** occur, no unnecessary I/O happens.
            ** 这实际是一个延迟移动,直到游标开始读记录之前,什么也不会发生.这意味着,如果没有读发生.
            ** 也不会有IO产生.
            */
            case OP_Seek:      /* in2 */
            {
                VdbeCursor *pC;
                pC = p->apCsr[pOp->p1];
                if (ALWAYS(pC->pCursor != 0))
                {
                    pC->nullRow = 0;
                    pIn2 = &aMem[pOp->p2];
                    pC->movetoTarget = sqlite3VdbeIntValue(pIn2); /* 记录下移动的目的 */
                    pC->rowidIsValid = 0;
                    pC->deferredMoveto = 1; /* 游标需要延迟移动 */
                }
                break;
            }
```
## SetCookie

操作码为:

```c
SetCookie P1 P2 P3 * *
```

将寄存器P3中的内容写入数据库P1的文件头部,P2用于指示写在哪个位置.其实写入的都是4个字节的整数.
P2 == 1 -> schema version [schema版本]
P2 == 2 -> database format [数据库格式]
P2 == 3 -> recommended pager cache size [推荐的pager cache大小]
P1 == 0,表示主数据库文件,P1 == 1,用于存储临时表的数据库

```c
		   /* Opcode: SetCookie P1 P2 P3 * *
            **
            ** Write the content of register P3 (interpreted as an integer)
            ** into cookie number P2 of database P1.  P2==1 is the schema version.
            ** P2==2 is the database format. P2==3 is the recommended pager cache
            ** size, and so forth.  P1==0 is the main database file and P1==1 is the
            ** database file used to store temporary tables.
            ** 将寄存器P3中的内容写入数据库P1的文件头部,P2用于指示写在哪个位置.其实写入的都是4个字节
            ** 的整数.
            ** P2 == 1 -> schema version [schema版本]
            ** P2 == 2 -> database format [数据库格式]
            ** P2 == 3 -> recommended pager cache size [推荐的pager cache大小]
            ** P1 == 0,表示主数据库文件,P1 == 1,用于存储临时表的数据库
            **
            ** A transaction must be started before executing this opcode.
            */
            case OP_SetCookie:         /* in3 */
            {
                Db *pDb;
                pDb = &db->aDb[pOp->p1];
                pIn3 = &aMem[pOp->p3];
                sqlite3VdbeMemIntegerify(pIn3);
                /* See note about index shifting on OP_ReadCookie */
                rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, (int)pIn3->u.i);
                if (pOp->p2 == BTREE_SCHEMA_VERSION)
                {
                    /* When the schema cookie changes, record the new cookie internally */
                    pDb->pSchema->schema_cookie = (int)pIn3->u.i;
                    db->flags |= SQLITE_InternChanges;
                }
                else if (pOp->p2 == BTREE_FILE_FORMAT)
                {
                    /* Record changes in the file format */
                    pDb->pSchema->file_format = (u8)pIn3->u.i;
                }
                if (pOp->p1 == 1)
                {
                    /* Invalidate all prepared statements whenever the TEMP database
                    ** schema is changed.  Ticket #1644 */
                    sqlite3ExpirePreparedStatements(db);
                    p->expired = 0;
                }
                break;
            }
```

## SorterOpen

操作码为:

```c
OpenSorter P1 P2 * P4 *
```

此操作符类似于OP_OpenEphemeral,它打开一个临时的索引.

```c
            /* Opcode: OpenSorter P1 P2 * P4 *
            **
            ** This opcode works like OP_OpenEphemeral except that it opens
            ** a transient index that is specifically designed to sort large
            ** tables using an external merge-sort algorithm.
            ** 此操作符类似于OP_OpenEphemeral,它打开一个临时的索引
            */
            case OP_SorterOpen:
            {
                VdbeCursor *pCx;
#ifndef SQLITE_OMIT_MERGE_SORT
                pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, 1);
                if (pCx == 0) goto no_mem;
                pCx->pKeyInfo = pOp->p4.pKeyInfo;
                pCx->pKeyInfo->enc = ENC(p->db);
                pCx->isSorter = 1;
                rc = sqlite3VdbeSorterInit(db, pCx);
#else
                pOp->opcode = OP_OpenEphemeral;
                pc--;
#endif
                break;
            }
```



## SorterInsert

操作码为:

```c
SorterInsert P1 P2 P3 * P5
```

寄存器P2持有一个通过MakeRecord指令创建的SQL index key, 此操作码将key通过游标P1写入,entry的数据为nil(空).

P3是一个标记,用于给b-tree层提供信息,插入很可能是追加.

```c
            /* Opcode: IdxInsert P1 P2 P3 * P5
            **
            ** Register P2 holds an SQL index key made using the
            ** MakeRecord instructions.  This opcode writes that key
            ** into the index P1.  Data for the entry is nil.
            ** 寄存器P2持有一个通过MakeRecord指令创建的SQL index key, 此操作码将key通过游标P1写入
            ** entry的数据为nil(空)
            **
            ** P3 is a flag that provides a hint to the b-tree layer that this
            ** insert is likely to be an append.
            ** P3是一个标记,用于给b-tree层提供信息,插入很可能是追加.
            **
            ** This instruction only works for indices.  The equivalent instruction
            ** for tables is OP_Insert.
            */
            case OP_SorterInsert:       /* in2 */
#ifdef SQLITE_OMIT_MERGE_SORT
                pOp->opcode = OP_IdxInsert;
#endif
            {
                VdbeCursor *pC;
                BtCursor *pCrsr;
                int nKey;
                const char *zKey;

                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);
                pC = p->apCsr[pOp->p1];
                assert(pC != 0);
                assert(pC->isSorter == (pOp->opcode == OP_SorterInsert));
                pIn2 = &aMem[pOp->p2];
                assert(pIn2->flags & MEM_Blob);
                pCrsr = pC->pCursor;
                if (ALWAYS(pCrsr != 0))
                {
                    assert(pC->isTable == 0);
                    rc = ExpandBlob(pIn2);
                    if (rc == SQLITE_OK)
                    {
                        if (isSorter(pC))
                        {
                            rc = sqlite3VdbeSorterWrite(db, pC, pIn2);
                        }
                        else
                        {
                            nKey = pIn2->n;
                            zKey = pIn2->z;
                            /* 插入数据,仅有key,没有data */
                            rc = sqlite3BtreeInsert(pCrsr, zKey, nKey, "", 0, 0, pOp->p3,
                                                    ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
                                                   );
                            assert(pC->deferredMoveto == 0);
                            pC->cacheStatus = CACHE_STALE;
                        }
                    }
                }
                break;
            }
```

## SorterData

操作码为:

```c
SorterData P1 P2 * * *
```

将当前排序游标P1指向的值写入P2寄存器.

```c
            /* Opcode: SorterData P1 P2 * * *
            **
            ** Write into register P2 the current sorter data for sorter cursor P1.
            ** 将当前排序游标P1指向的值写入P2寄存器
            */
            case OP_SorterData:
            {
                VdbeCursor *pC;
#ifndef SQLITE_OMIT_MERGE_SORT
                pOut = &aMem[pOp->p2];
                pC = p->apCsr[pOp->p1];
                rc = sqlite3VdbeSorterRowkey(pC, pOut);
#else
                pOp->opcode = OP_RowKey;
                pc--;
#endif
                break;
            }

```

## SorterNext

操作码为:

```c
SorterNext P1 P2 * P4 P5
```

移动游标P1,让其指向一下一个key/data对,如果游标到了最后的位置,跳转到下一条指令,否则跳转到指令P2处继续执行.

这条指令和Next没有区别.

```c
            /* Opcode: SorterNext P1 P2 * P4 P5
            **
            ** Advance cursor P1 so that it points to the next key/data pair in its
            ** table or index.  If there are no more key/value pairs then fall through
            ** to the following instruction.  But if the cursor advance was successful,
            ** jump immediately to P2.
            ** 移动游标P1,让其指向一下一个key/data对,如果游标到了最后的位置,跳转到下一条指令,
            ** 否则跳转到指令P2处继续执行
            **
            ** The P1 cursor must be for a real table, not a pseudo-table.
            ** 游标P1必须指向一个真表,而不是一个伪表.
            **
            ** P4 is always of type P4_ADVANCE. The function pointer points to
            ** sqlite3BtreeNext().
            ** P4的类型为ADVANCE,这个函数指针指向sqlite3BtreeNext()
            **
            ** If P5 is positive and the jump is taken, then event counter
            ** number P5-1 in the prepared statement is incremented.
            ** 如果P5为正数,并且跳转发生了,那么在prepared statement中的事件计数器P5-1会递增.
            **
            ** See also: Prev
            */
            case OP_SorterNext:    /* jump */
```

## SorterCompare

操作码为:

```c
SorterCompare P1 P2 P3
```

游标P1用于排序,此条指令比较排序游标当前指向的记录以及寄存器P3中的blob类型的记录.如果在排除了rowid这一列之后,两个记录匹配,跳转到下一条指令,否则跳转到指令P2处执行.

```c
            /* Opcode: SorterCompare P1 P2 P3
            **
            ** P1 is a sorter cursor. This instruction compares the record blob in
            ** register P3 with the entry that the sorter cursor currently points to.
            ** If, excluding the rowid fields at the end, the two records are a match,
            ** fall through to the next instruction. Otherwise, jump to instruction P2.
            ** 游标P1用于排序,此条指令比较排序游标当前指向的记录以及寄存器P3中的blob类型的记录.
            ** 如果在排除了rowid这一列之后,两个记录匹配,跳转到下一条指令,否则跳转到指令P2处执行.
            */
            case OP_SorterCompare:
            {
                VdbeCursor *pC;
                int res;

                pC = p->apCsr[pOp->p1];
                pIn3 = &aMem[pOp->p3];
                rc = sqlite3VdbeSorterCompare(pC, pIn3, &res);
                if (res)
                {
                    pc = pOp->p2 - 1;
                }
                break;
            };
```

## SeekLt && SeekLe && SeekGe && SeekGt

操作码为:

```c
SeekLt P1 P2 P3 P4 *
SeekLe P1 P2 P3 P4 *
SeekGe P1 P2 P3 P4 *
SeekGt P1 P2 P3 P4 *
```

如果游标P1指向一个SQL表(使用整型key的B-tree),使用寄存器P3中的值作为key,如果游标P1指向一个SQL索引,那么从寄存器P3位置开始一共P4个寄存器作为unpacket index key.

重新定位游标P1,使得它指向满足条件的最小的记录: 记录的key小于等于(Le)/小于(Lt)/大于等于(Ge)/大于(Gt)指令提供的key.如果没有满足条件的记录,那么跳转到P2执行.

# T

## Transaction

操作码为:

```c
Transaction P1 P2 * * *
```

P1是数据库文件的索引值,Index0代表主数据库文件,index1是用于存储临时表的文件.indix2以及更多,表示的是attached database.

如果P2是非空,那么开始一个写事务,获取一个RESERVED锁.开启了一个写事务,同时也会创建一个回滚日志,更改数据库文件之前必须开启一个写事务.

如果写事务开始了,并且Vdbe.usesStmtJournal标记为true, 一个statement事务将会开启.更加具体的,一个statement事务开启,如果当前数据库连接不处于autocommit模式

```c
           /* Opcode: Transaction P1 P2 * * *
            **
            ** Begin a transaction.  The transaction ends when a Commit or Rollback
            ** opcode is encountered.  Depending on the ON CONFLICT setting, the
            ** transaction might also be rolled back if an error is encountered.
            ** 开始一个事务,事务将以commit或者rollback结尾.
            **
            ** P1 is the index of the database file on which the transaction is
            ** started.  Index 0 is the main database file and index 1 is the
            ** file used for temporary tables.  Indices of 2 or more are used for
            ** attached databases.
            ** P1是数据库文件的索引值,Index0代表主数据库文件,index1是用于存储临时表的文件.
            ** indix2以及更多,表示的是attached database
            **
            ** If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is
            ** obtained on the database file when a write-transaction is started.  No
            ** other process can start another write transaction while this transaction is
            ** underway.  Starting a write transaction also creates a rollback journal. A
            ** write transaction must be started before any changes can be made to the
            ** database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained
            ** on the file.
            ** 如果P2是非空,那么开始一个写事务,获取一个RESERVED锁.
            ** 开启了一个写事务,同时也会创建一个回滚日志,更改数据库文件之前必须开启一个写事务.
            **
            ** If a write-transaction is started and the Vdbe.usesStmtJournal flag is
            ** true (this flag is set if the Vdbe may modify more than one row and may
            ** throw an ABORT exception), a statement transaction may also be opened.
            ** More specifically, a statement transaction is opened iff the database
            ** connection is currently not in autocommit mode, or if there are other
            ** active statements. A statement transaction allows the changes made by this
            ** VDBE to be rolled back after an error without having to roll back the
            ** entire transaction. If no error is encountered, the statement transaction
            ** will automatically commit when the VDBE halts.
            ** 如果写事务开始了,并且Vdbe.usesStmtJournal 标记为true, 一个statement事务将会开启.
            ** 更加具体的,一个statement事务开启,如果当前数据库连接不处于autocommit模式
            **
            ** If P2 is zero, then a read-lock is obtained on the database file.
            */
            case OP_Transaction:
            {
                Btree *pBt;
                pBt = db->aDb[pOp->p1].pBt; /* 获得数据库的btree */

                if (pBt)
                {
                    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2); /* 创建一个事务 */
                    if (rc == SQLITE_BUSY)
                    {
                        p->pc = pc;
                        p->rc = rc = SQLITE_BUSY;
                        goto vdbe_return;
                    }
                    if (rc != SQLITE_OK)
                    {
                        goto abort_due_to_error;
                    }

                    if (pOp->p2 && p->usesStmtJournal
                        && (db->autoCommit == 0 || db->activeVdbeCnt > 1)
                       )
                    {
                        assert(sqlite3BtreeIsInTrans(pBt));
                        if (p->iStatement == 0)
                        {
                            db->nStatement++;
                            p->iStatement = db->nSavepoint + db->nStatement;
                        }
                        rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN, p->iStatement - 1);
                        if (rc == SQLITE_OK)
                        {
                            rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);
                        }

                        /* Store the current value of the database handles deferred constraint
                        ** counter. If the statement transaction needs to be rolled back,
                        ** the value of this counter needs to be restored too.  */
                        p->nStmtDefCons = db->nDeferredCons;
                    }
                }
                break;
            }
```

# U

# V
## Variable

操作码为:

```c
Variable P1 P2 * P4 *
```

将参数P1的值传入寄存器P2.

```c
            /* Opcode: Variable P1 P2 * P4 *
            **
            ** Transfer the values of bound parameter P1 into register P2
            ** 将参数P1的值传入寄存器P2.
            ** If the parameter is named, then its name appears in P4 and P3==1.
            ** The P4 value is used by sqlite3_bind_parameter_name().
            ** 如果参数有名称,那么它的名称在P4之中,而且P3==1,P4的值被sqlite3_bind_parameter_name()所采用.
            */
            case OP_Variable:              /* out2-prerelease */
            {
                Mem *pVar;       /* Value being transferred */
                pVar = &p->aVar[pOp->p1 - 1];
                if (sqlite3VdbeMemTooBig(pVar))
                {
                    goto too_big;
                }
                sqlite3VdbeMemShallowCopy(pOut, pVar, MEM_Static);
                UPDATE_MAX_BLOBSIZE(pOut);
                break;
            }
```
## VerifyCookie

操作码为:

```c
VerifyCookie P1 P2 P3 * *
```

检查全局数据库参数值0(schema版本),确保它等于P2,并且generation计数值(在本地schema)等于P3.

P1是数据库的编号,0代表main database, 1代表存储有临时表的database.

每当数据库架构更改时,cookie都会更改其值,该操作用于检测cookie值已经发生更改,当前进程需要重新读取schema.

```c
            /* Opcode: VerifyCookie P1 P2 P3 * *
            **
            ** Check the value of global database parameter number 0 (the
            ** schema version) and make sure it is equal to P2 and that the
            ** generation counter on the local schema parse equals P3.
            ** 检查全局数据库参数值0(schema版本),确保它等于P2,并且generation计数值(在本地schema)
            ** 等于P3
            **
            ** P1 is the database number which is 0 for the main database file
            ** and 1 for the file holding temporary tables and some higher number
            ** for auxiliary databases.
            ** P1是数据库的编号,0代表main database, 1代表存储有临时表的database
            **
            ** The cookie changes its value whenever the database schema changes.
            ** This operation is used to detect when that the cookie has changed
            ** and that the current process needs to reread the schema.
            ** 每当数据库架构更改时,cookie都会更改其值,该操作用于检测cookie值已经发生更改,当前进程
            ** 需要重新读取schema
            **
            ** Either a transaction needs to have been started or an OP_Open needs
            ** to be executed (to establish a read lock) before this opcode is
            ** invoked.
            */
            case OP_VerifyCookie:
            {
                int iMeta;
                int iGen;
                Btree *pBt;

                pBt = db->aDb[pOp->p1].pBt; /* 获取对应数据库的btree */
                if (pBt)
                {
                    sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&iMeta);
                    iGen = db->aDb[pOp->p1].pSchema->iGeneration; /* 记录下原本的值 */
                }
                else
                {
                    iGen = iMeta = 0;
                }
                if (iMeta != pOp->p2 || iGen != pOp->p3)
                {
                    sqlite3DbFree(db, p->zErrMsg);
                    p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");
                    /* If the schema-cookie from the database file matches the cookie
                    ** stored with the in-memory representation of the schema, do
                    ** not reload the schema from the database file.
                    ** 如果从数据库文件中的schema-cookie值和内存中的schema-cookie值匹配,无需重新读取schema
                    **
                    ** If virtual-tables are in use, this is not just an optimization.
                    ** Often, v-tables store their data in other SQLite tables, which
                    ** are queried from within xNext() and other v-table methods using
                    ** prepared queries. If such a query is out-of-date, we do not want to
                    ** discard the database schema, as the user code implementing the
                    ** v-table would have to be ready for the sqlite3_vtab structure itself
                    ** to be invalidated whenever sqlite3_step() is called from within
                    ** a v-table method.
                    */
                    if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta)
                    {
                        sqlite3ResetOneSchema(db, pOp->p1);
                    }

                    p->expired = 1;
                    rc = SQLITE_SCHEMA;
                }
                break;
            }
```

# W && X

# Y

## Yield

操作码为:

```c
Yield P1 * * * *
```

交换pc以及register P1中的值.

```c
            /* Opcode:  Yield P1 * * * *
            **
            ** Swap the program counter with the value in register P1.
            ** 交换pc以及register P1中的值
            */
            case OP_Yield:              /* in1 */
            {
                int pcDest;
                pIn1 = &aMem[pOp->p1];
                pIn1->flags = MEM_Int;
                pcDest = (int)pIn1->u.i;
                pIn1->u.i = pc;
                pc = pcDest;
                break;
            }
```
# Z
